/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../../trebor-transitions/node_modules/hash-sum/hash-sum.js":
/*!****************************************************************************!*\
  !*** h:/trebor-repos/trebor-transitions/node_modules/hash-sum/hash-sum.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction pad (hash, len) {\n  while (hash.length < len) {\n    hash = '0' + hash;\n  }\n  return hash;\n}\n\nfunction fold (hash, text) {\n  var i;\n  var chr;\n  var len;\n  if (text.length === 0) {\n    return hash;\n  }\n  for (i = 0, len = text.length; i < len; i++) {\n    chr = text.charCodeAt(i);\n    hash = ((hash << 5) - hash) + chr;\n    hash |= 0;\n  }\n  return hash < 0 ? hash * -2 : hash;\n}\n\nfunction foldObject (hash, o, seen) {\n  return Object.keys(o).sort().reduce(foldKey, hash);\n  function foldKey (hash, key) {\n    return foldValue(hash, o[key], key, seen);\n  }\n}\n\nfunction foldValue (input, value, key, seen) {\n  var hash = fold(fold(fold(input, key), toString(value)), typeof value);\n  if (value === null) {\n    return fold(hash, 'null');\n  }\n  if (value === undefined) {\n    return fold(hash, 'undefined');\n  }\n  if (typeof value === 'object') {\n    if (seen.indexOf(value) !== -1) {\n      return fold(hash, '[Circular]' + key);\n    }\n    seen.push(value);\n    return foldObject(hash, value, seen);\n  }\n  return fold(hash, value.toString());\n}\n\nfunction toString (o) {\n  return Object.prototype.toString.call(o);\n}\n\nfunction sum (o) {\n  return pad(foldValue(0, o, '', []).toString(16), 8);\n}\n\nmodule.exports = sum;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vaDovdHJlYm9yLXJlcG9zL3RyZWJvci10cmFuc2l0aW9ucy9ub2RlX21vZHVsZXMvaGFzaC1zdW0vaGFzaC1zdW0uanM/M2Y5YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuLi8uLi8uLi8uLi90cmVib3ItdHJhbnNpdGlvbnMvbm9kZV9tb2R1bGVzL2hhc2gtc3VtL2hhc2gtc3VtLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBwYWQgKGhhc2gsIGxlbikge1xuICB3aGlsZSAoaGFzaC5sZW5ndGggPCBsZW4pIHtcbiAgICBoYXNoID0gJzAnICsgaGFzaDtcbiAgfVxuICByZXR1cm4gaGFzaDtcbn1cblxuZnVuY3Rpb24gZm9sZCAoaGFzaCwgdGV4dCkge1xuICB2YXIgaTtcbiAgdmFyIGNocjtcbiAgdmFyIGxlbjtcbiAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gdGV4dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNociA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBjaHI7XG4gICAgaGFzaCB8PSAwO1xuICB9XG4gIHJldHVybiBoYXNoIDwgMCA/IGhhc2ggKiAtMiA6IGhhc2g7XG59XG5cbmZ1bmN0aW9uIGZvbGRPYmplY3QgKGhhc2gsIG8sIHNlZW4pIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG8pLnNvcnQoKS5yZWR1Y2UoZm9sZEtleSwgaGFzaCk7XG4gIGZ1bmN0aW9uIGZvbGRLZXkgKGhhc2gsIGtleSkge1xuICAgIHJldHVybiBmb2xkVmFsdWUoaGFzaCwgb1trZXldLCBrZXksIHNlZW4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvbGRWYWx1ZSAoaW5wdXQsIHZhbHVlLCBrZXksIHNlZW4pIHtcbiAgdmFyIGhhc2ggPSBmb2xkKGZvbGQoZm9sZChpbnB1dCwga2V5KSwgdG9TdHJpbmcodmFsdWUpKSwgdHlwZW9mIHZhbHVlKTtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZvbGQoaGFzaCwgJ251bGwnKTtcbiAgfVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmb2xkKGhhc2gsICd1bmRlZmluZWQnKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChzZWVuLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGZvbGQoaGFzaCwgJ1tDaXJjdWxhcl0nICsga2V5KTtcbiAgICB9XG4gICAgc2Vlbi5wdXNoKHZhbHVlKTtcbiAgICByZXR1cm4gZm9sZE9iamVjdChoYXNoLCB2YWx1ZSwgc2Vlbik7XG4gIH1cbiAgcmV0dXJuIGZvbGQoaGFzaCwgdmFsdWUudG9TdHJpbmcoKSk7XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nIChvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cbmZ1bmN0aW9uIHN1bSAobykge1xuICByZXR1cm4gcGFkKGZvbGRWYWx1ZSgwLCBvLCAnJywgW10pLnRvU3RyaW5nKDE2KSwgOCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3VtO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../../trebor-transitions/node_modules/hash-sum/hash-sum.js\n");

/***/ }),

/***/ "./main.ts":
/*!*****************************!*\
  !*** ./main.ts + 5 modules ***!
  \*****************************/
/*! no exports provided */
/*! ModuleConcatenation bailout: Cannot concat with h:/trebor-repos/trebor-transitions/node_modules/hash-sum/hash-sum.js (<- Module is not an ECMAScript module) */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("\n// CONCATENATED MODULE: h:/trebor-repos/trebor-tools/index.js\nvar PROPS = ['$slots', '$refs', '$filters', '$directives', '_events', '_watchers'];\r\nvar PROP_MAP = { p: '__TP__', v: 'value', _: '_value', s: '_subscribers', e: '_events', w: '_watchers', h: 'prototype' };\r\nvar TPS = window[PROP_MAP.p] || (window[PROP_MAP.p] = []);\n\nvar array = Array[PROP_MAP.h];\r\nfunction _$toArgs(args, start) {\r\n    if (start === void 0) { start = 0; }\r\n    return array.slice.call(args, start);\r\n}\r\nfunction _$arrayValues(list, value, root, key) {\r\n    array.push.apply(list, value.map(function (v, i) {\r\n        if (list.length !== 0)\r\n            i += list.length;\r\n        return !(_$isType(v, _$List)) && _$isArray(v) ? new _$List(v, root, key + \".\" + i) : v;\r\n    }));\r\n}\r\nfunction _$List(value, root, key) {\r\n    var self = this;\r\n    Array.apply(self, [value.length]);\r\n    var desc = { writable: false, configurable: false, enumerable: false };\r\n    _$define(self, '_key', _$assign({ value: key }, desc));\r\n    _$define(self, '_root', _$assign({ value: root }, desc));\r\n    _$arrayValues(self, value, root, key);\r\n    desc.writable = true;\r\n    _$define(self, 'length', _$assign({ value: self.length }, desc));\r\n}\r\n_$extends(_$List, Array);\r\n['pop', 'push', 'reverse', 'shift', 'sort', 'fill', 'unshift', 'splice'].forEach(function (method) {\r\n    _$List[PROP_MAP.h][method] = function () {\r\n        var self = this;\r\n        var old = self.slice();\r\n        var result;\r\n        if (method === 'push') {\r\n            _$arrayValues(self, _$toArgs(arguments), self._root, self._key);\r\n            result = self.length;\r\n        }\r\n        else {\r\n            result = array[method].apply(self, arguments);\r\n        }\r\n        _$dispatch(self._root, self._key, old, self.slice());\r\n        return result;\r\n    };\r\n});\r\n_$List[PROP_MAP.h].pull = function (index) {\r\n    var self = this;\r\n    var items = _$toArgs(arguments, 1);\r\n    var length = self.length;\r\n    if (index > length) {\r\n        length = index + 1;\r\n        var pull = new Array(index - self.length);\r\n        pull.push.apply(pull, items);\r\n        for (var i = 0; i < length; i++) {\r\n            if (i === index) {\r\n                self.push.apply(self, pull);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        self.splice.apply(self, [index, 1].concat(items));\r\n    }\r\n};\n\nfunction _$select(selector, parent) {\r\n    return _$isString(selector) ? (parent || document).querySelector(selector) : selector;\r\n}\r\nfunction _$docFragment() {\r\n    return document.createDocumentFragment();\r\n}\r\nfunction _$append(parent, child, sibling) {\r\n    if (_$isType(sibling, 'boolean') && sibling)\r\n        parent.parentElement.replaceChild(child, parent);\r\n    else if (!sibling)\r\n        parent.appendChild(child);\r\n    else\r\n        parent.insertBefore(child, sibling);\r\n}\r\nfunction _$assignEl(source, dest) {\r\n    var childNodes = source.childNodes, attributes = source.attributes;\r\n    for (var i = 0; i < childNodes.length; i++) {\r\n        _$append(dest, childNodes[i]);\r\n    }\r\n    for (var i = 0; i < attributes.length; i++) {\r\n        var attr = attributes[i];\r\n        dest.setAttributeNS(source.namespaceURI, attr.name, attr.value);\r\n    }\r\n    source.parentElement.replaceChild(dest, source);\r\n    return dest;\r\n}\r\nfunction _$removeEl(el, parent) {\r\n    var root = parent || el.parentElement;\r\n    if (root)\r\n        root.removeChild(el);\r\n}\r\nfunction _$el(tagName) {\r\n    return document.createElement(tagName || 'div');\r\n}\r\nfunction _$svg(tagName) {\r\n    return document.createElementNS('http://www.w3.org/2000/svg', tagName || 'svg');\r\n}\r\nfunction _$text(content) {\r\n    return document.createTextNode(content || '');\r\n}\r\nfunction _$comment(content) {\r\n    return document.createComment(content || '');\r\n}\r\nfunction _$setAttr(el, attrAndValue) {\r\n    var attr = attrAndValue[0], value = attrAndValue[1];\r\n    el.setAttribute(attr, _$toString(value));\r\n    if (_$isValueAttr(attr) && !_$isString(value))\r\n        el[PROP_MAP._] = value;\r\n}\r\nfunction _$getAttr(el, attr) {\r\n    return _$isValueAttr(attr) ? _$getValue(el) : el.getAttribute(attr);\r\n}\r\nfunction _$getValue(el) {\r\n    return _$hasProp(el, PROP_MAP._) ? el[PROP_MAP._] : el[PROP_MAP.v];\r\n}\r\nfunction _$addListener(el, event, handler) {\r\n    el.addEventListener(event, handler, false);\r\n}\r\nfunction _$updateListener(el, event, oldHandler, newHandler) {\r\n    _$removeListener(el, event, oldHandler);\r\n    _$addListener(el, event, oldHandler = newHandler);\r\n    return oldHandler;\r\n}\r\nfunction _$removeListener(el, event, handler) {\r\n    el.removeEventListener(event, handler, false);\r\n}\r\nfunction _$bindGroup(input, selection) {\r\n    var _value = _$getValue(input);\r\n    var _$index = selection.indexOf(_value);\r\n    input.checked && !~_$index ? selection.push(_value) : selection.splice(_$index, 1);\r\n}\r\nfunction _$bindMultiSelect(select, selections) {\r\n    if (!selections.length)\r\n        return;\r\n    var options = select.options;\r\n    for (var i = 0; i < options.length; i++) {\r\n        options[i].selected = !!~selections.indexOf(_$getValue(options[i]));\r\n    }\r\n}\r\nfunction _$updateMultiSelect(select, obj, prop) {\r\n    var items = [];\r\n    var selection = obj[prop];\r\n    var selectedOptions = select.selectedOptions;\r\n    for (var i = 0; i < selectedOptions.length; i++) {\r\n        items.push(_$getValue(selectedOptions[i]));\r\n    }\r\n    obj[prop] = new _$List(items, selection['_root'], selection['_key']);\r\n    obj.$update();\r\n}\r\nfunction _$insertStyle(id, css) {\r\n    var isNew = false;\r\n    var style = _$select(\"#\" + id, document.head);\r\n    if (!style) {\r\n        isNew = true;\r\n        style = _$el('style');\r\n        style.id = id;\r\n        _$setAttr(style, ['refs', 1]);\r\n    }\r\n    if (style.textContent !== css) {\r\n        style.textContent = css;\r\n    }\r\n    if (isNew) {\r\n        _$append(document.head, style);\r\n    }\r\n    else {\r\n        var count = +_$getAttr(style, 'refs');\r\n        _$setAttr(style, ['refs', ++count]);\r\n    }\r\n}\r\nfunction _$removeStyle(id) {\r\n    var style = _$select(\"#\" + id, document.head);\r\n    if (style) {\r\n        var count = +_$getAttr(style, 'refs');\r\n        if (--count === 0) {\r\n            _$removeEl(style, document.head);\r\n        }\r\n        else {\r\n            _$setAttr(style, ['refs', count]);\r\n        }\r\n    }\r\n}\n\nfunction _$toLowerCase(str) {\r\n    return str.toLowerCase();\r\n}\r\nvar _$assign = Object['assign'] || function (t) {\r\n    for (var s = void 0, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s)\r\n            if (_$hasProp(s, p))\r\n                t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nfunction _$apply(callee, args, globs, thisArg) {\r\n    if (thisArg === void 0) { thisArg = null; }\r\n    return callee.apply(thisArg, args.concat(globs));\r\n}\r\nfunction _$isValueAttr(attr) {\r\n    return attr === 'value';\r\n}\r\nfunction _$subscribers(dep, listener) {\r\n    if (!this[PROP_MAP.s][dep]) {\r\n        this[PROP_MAP.s][dep] = [];\r\n    }\r\n    return this[PROP_MAP.s][dep].push(listener.bind(this)) - 1;\r\n}\r\nfunction _$define(obj, key, desc) {\r\n    Object.defineProperty(obj, key, desc);\r\n}\r\nfunction _$dispatch(root, key, oldVal, value) {\r\n    root.$notify(key);\r\n    if (root[PROP_MAP.w][key]) {\r\n        _$each(root[PROP_MAP.w][key], function (watcher) { watcher(oldVal, value); });\r\n    }\r\n    root.$update();\r\n}\r\nfunction _$extends(ctor, exts) {\r\n    ctor[PROP_MAP.h] = Object.create(exts[PROP_MAP.h]);\r\n    ctor[PROP_MAP.h].constructor = ctor;\r\n}\r\nfunction _$isType(value, type) {\r\n    return _$type(type) === 'string' ? type.split('\\|').some(function (t) { return t.trim() === _$type(value); }) : value instanceof type;\r\n}\r\nfunction _$isObject(obj) {\r\n    return _$isType(obj, 'object');\r\n}\r\nfunction _$isArray(obj) {\r\n    return Array.isArray ? Array.isArray(obj) : _$isType(obj, 'array');\r\n}\r\nfunction _$isFunction(obj) {\r\n    return _$isType(obj, 'function');\r\n}\r\nfunction _$isString(obj) {\r\n    return _$isType(obj, 'string');\r\n}\r\nfunction _$toType(value, type, root, key) {\r\n    switch (type) {\r\n        case 'date':\r\n            return new Date(value);\r\n        case 'string':\r\n            return _$toString(value);\r\n        case 'number':\r\n            return +value;\r\n        case 'boolean':\r\n            return _$isString(value) && !value ? true : !!value;\r\n        case 'array':\r\n            return _$isType(value, _$List) ? value : new _$List(value, root, key);\r\n        default:\r\n            return value;\r\n    }\r\n}\r\nfunction _$type(obj) {\r\n    return _$toLowerCase(/ (\\w+)/.exec({}.toString.call(obj))[1]);\r\n}\r\nfunction _$hasProp(obj, prop) {\r\n    return obj.hasOwnProperty(prop);\r\n}\r\nfunction _$directive(dd) {\r\n    var hasProp = function (prop, instance, options, element) { return _$isObject(dd) && dd[prop] && dd[prop](instance, options, element); };\r\n    return {\r\n        $init: function (instance, options, element) {\r\n            hasProp('$init', instance, options, element);\r\n        },\r\n        $inserted: function (instance, options, element) {\r\n            hasProp('$inserted', instance, options, element);\r\n        },\r\n        $update: function (instance, options, element) {\r\n            if (_$isFunction(dd)) {\r\n                dd(instance, options, element);\r\n            }\r\n            else {\r\n                hasProp('$update', instance, options, element);\r\n            }\r\n        },\r\n        $destroy: function (instance, options, element) {\r\n            hasProp('$destroy', instance, options, element);\r\n        }\r\n    };\r\n}\r\nfunction _$noop() { }\r\nfunction _$addChild(inst, Child, attrs) {\r\n    var child = null;\r\n    if (Child) {\r\n        child = new Child(attrs, inst);\r\n        inst.$children.push(child);\r\n    }\r\n    return child;\r\n}\r\nfunction _$removeChild(inst, child) {\r\n    var index = inst.$children.indexOf(child);\r\n    index >= 0 && inst.$children.splice(index, 1);\r\n}\r\nfunction _$toString(obj) {\r\n    var str = _$type(obj);\r\n    return !/null|undefined/.test(str) ? obj.toString() : str;\r\n}\r\nfunction _$toPlainObject(obj) {\r\n    var data = {};\r\n    _$each(_$isObject(obj) ? obj : {}, function (_v, k) {\r\n        if (k[0] !== '$' && !_$isFunction(obj[k])) {\r\n            if (_$isType(obj[k], _$List)) {\r\n                data[k] = obj[k].map(_$toPlainObject);\r\n            }\r\n            else if (_$isObject(obj[k])) {\r\n                data[k] = _$toPlainObject(obj[k]);\r\n            }\r\n            else {\r\n                data[k] = obj[k];\r\n            }\r\n        }\r\n    });\r\n    return _$isObject(obj) ? data : obj;\r\n}\r\nfunction _$setReference(refs, prop, node) {\r\n    if (!_$hasProp(refs, prop)) {\r\n        var value_1 = [];\r\n        _$define(refs, prop, {\r\n            get: function () { return value_1.length <= 1 ? value_1[0] : value_1; },\r\n            set: function (val) { val && !~value_1.indexOf(val) && value_1.push(val); },\r\n            enumerable: true, configurable: true\r\n        });\r\n    }\r\n    refs[prop] = node;\r\n}\r\nfunction _$accesor(object, path, value) {\r\n    return path.split('.').reduce(function (obj, key, i, arr) {\r\n        if (_$isType(value, 'undefined')) {\r\n            if (obj == null) {\r\n                arr.splice(0, arr.length);\r\n                return i > 0 && obj === null ? obj : undefined;\r\n            }\r\n        }\r\n        else {\r\n            if (i === arr.length - 1) {\r\n                if (_$isType(obj, _$List) && _$toString(+key) === key) {\r\n                    obj.pull(+key, value);\r\n                }\r\n                else {\r\n                    var oldVal = obj[key];\r\n                    obj[key] = !_$isType(value, _$List) && _$isArray(value) ? new _$List(value, object, key) : value;\r\n                    _$dispatch(object, path, oldVal, obj[key]);\r\n                }\r\n            }\r\n            else if (!_$isObject(obj[key])) {\r\n                obj[key] = {};\r\n            }\r\n        }\r\n        return obj ? obj[key] : null;\r\n    }, object);\r\n}\r\nfunction _$emptyElse() {\r\n    return { type: 'empty-else', $create: _$noop, $mount: _$noop, $update: _$noop, $destroy: _$noop };\r\n}\r\nfunction _$isKey(event, key) {\r\n    return _$toLowerCase(event.key) === key || !!event[key + \"Key\"];\r\n}\r\nfunction _$bindClasses(value) {\r\n    var classes = '';\r\n    if (_$isString(value)) {\r\n        classes += \" \" + value;\r\n    }\r\n    else if (_$isArray(value)) {\r\n        classes = value.map(_$bindClasses).join(' ');\r\n    }\r\n    else if (_$isObject(value)) {\r\n        for (var key in value)\r\n            if (_$hasProp(value, key) && value[key])\r\n                classes += \" \" + key;\r\n    }\r\n    return classes.trim();\r\n}\r\nfunction _$bindStyle(value) {\r\n    var el = _$el();\r\n    if (_$isObject(value)) {\r\n        var style_1 = el.style;\r\n        _$each(value, function (val, prop) {\r\n            if (val !== style_1[prop])\r\n                style_1[prop] = val;\r\n        });\r\n        return style_1.cssText;\r\n    }\r\n    else if (_$isString(value)) {\r\n        return value;\r\n    }\r\n    else {\r\n        return '';\r\n    }\r\n}\r\nfunction _$conditionalUpdate(block, condition, parent, anchor, inst) {\r\n    var globs = _$toArgs(arguments, 5);\r\n    if (block && block.type === _$apply(condition, [inst], globs).type) {\r\n        _$apply(block.$update, [inst], globs, block);\r\n    }\r\n    else {\r\n        block && block.$destroy();\r\n        block = _$apply(condition, [inst], globs);\r\n        block.$create();\r\n        block.$mount(parent || inst.$parentEl, anchor);\r\n    }\r\n    return block;\r\n}\r\nfunction _$bindUpdate(el, binding) {\r\n    var attr = binding[0], value = binding[1];\r\n    var _value = _$toString(value);\r\n    if (_$isValueAttr(attr)) {\r\n        if (el[attr] !== _value)\r\n            el[attr] = _value;\r\n        el[PROP_MAP._] = value;\r\n    }\r\n    else if (_$getAttr(el, attr) !== _value) {\r\n        _$setAttr(el, [attr, _value]);\r\n    }\r\n}\r\nfunction _$bindBooleanAttr(el, attrAndValue) {\r\n    var attr = attrAndValue[0], value = attrAndValue[1];\r\n    el[attr] = value == null || value === false ? (el.removeAttribute(attr), false) : (_$setAttr(el, [attr, '']), true);\r\n}\r\nfunction _$textUpdate(text, value) {\r\n    if (text.data !== (value = _$toString(value)))\r\n        text.data = value;\r\n}\r\nfunction _$tagUpdate(node, tag) {\r\n    return _$toLowerCase(tag) !== _$toLowerCase(node.tagName) ? _$assignEl(node, _$el(tag)) : node;\r\n}\r\nfunction _$removeReference(refs, prop, node) {\r\n    var nodes = refs[prop];\r\n    _$isArray(nodes) ? refs[prop].splice(nodes.indexOf(node), 1) : (delete refs[prop]);\r\n}\r\nfunction _$htmlUpdate(node, value) {\r\n    if (node.innerHTML !== (value = _$toString(value)))\r\n        node.innerHTML = value;\r\n}\r\nfunction _$componentUpdate(parent, Ctor, inst, value, attrs, el, sibling) {\r\n    if (value === Ctor) {\r\n        inst && inst.$update();\r\n    }\r\n    else {\r\n        Ctor = value;\r\n        if (inst) {\r\n            inst.$destroy();\r\n            _$removeChild(parent, inst);\r\n        }\r\n        if (inst) {\r\n            inst = _$addChild(parent, Ctor, attrs);\r\n            inst.$create();\r\n            inst.$mount(el, sibling);\r\n        }\r\n    }\r\n    return [inst, Ctor];\r\n}\r\nfunction _$destroyComponent(component) {\r\n    component.$unmount();\r\n    component.$parent = null;\r\n    component.$parentEl = null;\r\n    component.$siblingEl = null;\r\n    component.$children.splice(0, component.$children.length);\r\n}\r\nfunction _$setElements(component, parent, sibling) {\r\n    var brother = _$select(sibling);\r\n    component.$siblingEl = brother;\r\n    component.$parentEl = sibling && brother.parentElement || _$select(parent);\r\n}\r\nfunction _$forLoop(root, obj, loop) {\r\n    var items = {}, loopParent, loopSibling;\r\n    var globs = _$toArgs(arguments, 3);\r\n    _$each(obj, function (item, i, index) { items[i] = _$apply(loop, [root, item, i, index], globs); });\r\n    return {\r\n        $create: function () {\r\n            _$each(items, function (item) { item.$create(); });\r\n        },\r\n        $mount: function (parent, sibling) {\r\n            loopParent = _$select(parent);\r\n            loopSibling = _$select(sibling);\r\n            _$each(items, function (item) { item.$mount(loopParent, loopSibling); });\r\n        },\r\n        $update: function (root, obj) {\r\n            var globs = _$toArgs(arguments, 2);\r\n            _$each(items, function (item, i, index) {\r\n                if (obj[i]) {\r\n                    _$apply(item.$update, [root, obj[i], i, index], globs, item);\r\n                }\r\n                else {\r\n                    item.$destroy();\r\n                    delete items[i];\r\n                }\r\n            });\r\n            _$each(obj, function (item, i, index) {\r\n                if (!items[i]) {\r\n                    items[i] = _$apply(loop, [root, item, i, index], globs);\r\n                    items[i].$create();\r\n                    items[i].$mount(loopParent, loopSibling);\r\n                }\r\n            });\r\n        },\r\n        $destroy: function () {\r\n            _$each(items, function (item) { item.$destroy(); });\r\n        }\r\n    };\r\n}\r\nfunction _$each(obj, cb) {\r\n    var i = 0;\r\n    for (var key in obj) {\r\n        if (_$hasProp(obj, key)) {\r\n            cb(obj[key], (isNaN(+key) ? key : +key), i++);\r\n        }\r\n    }\r\n}\n\nfunction _$BaseComponent(attrs, template, options, parent) {\r\n    var self = this;\r\n    var _$set = function (prop, value) { _$define(self, prop, { value: value, writable: true }); };\r\n    if (!attrs)\r\n        attrs = {};\r\n    _$each(PROPS, function (prop) { _$define(self, prop, { value: {} }); });\r\n    _$set('$parent', parent || null);\r\n    _$set('$children', []);\r\n    _$set(PROP_MAP.s, {});\r\n    _$set('$options', options);\r\n    var opts = self.$options;\r\n    if (!opts.attrs)\r\n        opts.attrs = {};\r\n    if (!opts.children)\r\n        opts.children = {};\r\n    _$each(TPS, function (plugin) { plugin.fn.call(self, _$BaseComponent, plugin.options); });\r\n    if (opts.filters)\r\n        _$assign(self.$filters, opts.filters);\r\n    if (opts.directives)\r\n        _$each(opts.directives, function (drt, k) { self.$directives[k] = _$directive(drt); });\r\n    _$each(opts.attrs, function (attrOps, key) {\r\n        _$define(self, (_$isType(key, 'number') ? attrOps : key), {\r\n            get: function () {\r\n                if (_$isString(attrOps)) {\r\n                    var value = attrs[attrOps];\r\n                    return _$isFunction(value) ? value() : value;\r\n                }\r\n                else {\r\n                    if (!_$hasProp(attrs, key) && attrOps.required) {\r\n                        return console.error(\"Attribute '\" + key + \"' is required.\");\r\n                    }\r\n                    else {\r\n                        var value = _$isFunction(attrs[key]) ? attrs[key]() : attrs[key];\r\n                        if (value === void 0 && _$hasProp(attrOps, 'default')) {\r\n                            var def = attrOps.default;\r\n                            value = _$isFunction(def) ? def() : def;\r\n                        }\r\n                        var typ = attrOps.type;\r\n                        if (typ && !_$isType(value, typ) && attrOps.required) {\r\n                            return console.error(\"Attribute '\" + key + \"' must be type '\" + typ + \"'.\");\r\n                        }\r\n                        value = _$toType(value, value === void 0 ? 'undefined' : typ, self, key);\r\n                        if (value !== void 0 && _$hasProp(attrOps, 'validator')) {\r\n                            var validator = attrOps.validator;\r\n                            if (_$isFunction(validator) && !validator(value)) {\r\n                                return console.error(\"Assigment '\" + key + \"'='\" + JSON.stringify(value) + \"' invalid.\");\r\n                            }\r\n                        }\r\n                        return value;\r\n                    }\r\n                }\r\n            },\r\n            set: function () {\r\n                console.error(\"'\" + key + \"' is read only.\");\r\n            },\r\n            enumerable: true, configurable: true\r\n        });\r\n    });\r\n    var data = opts.model || {};\r\n    var _loop_1 = function (key) {\r\n        if (_$hasProp(data, key)) {\r\n            var desc = Object.getOwnPropertyDescriptor(data, key);\r\n            if (desc.value && _$isArray(desc.value)) {\r\n                desc.value = new _$List(desc.value, self, key);\r\n            }\r\n            else {\r\n                if (desc.get) {\r\n                    var getter_1 = desc.get;\r\n                    desc.get = function () {\r\n                        var value = getter_1.call(self);\r\n                        if (_$isArray(value))\r\n                            value = new _$List(value, self, key);\r\n                        return value;\r\n                    };\r\n                }\r\n                if (desc.set) {\r\n                    var setter_1 = desc.set;\r\n                    desc.set = function (v) {\r\n                        if (_$isArray(v))\r\n                            v = new _$List(v, self, key);\r\n                        setter_1.call(self, v);\r\n                    };\r\n                }\r\n            }\r\n            _$define(self, key, desc);\r\n        }\r\n    };\r\n    for (var key in data) {\r\n        _loop_1(key);\r\n    }\r\n    var tpl = template(self);\r\n    _$each(tpl, function (value, key) {\r\n        _$define(self, key, {\r\n            value: (function (key) {\r\n                var hook = key[1].toUpperCase() + key.slice(2);\r\n                var bhook = opts[\"will\" + hook];\r\n                var ahook = opts[\"did\" + hook];\r\n                return function () {\r\n                    bhook && bhook.call(this);\r\n                    key === '$update' ? value.call(this, this) : value.apply(this, arguments);\r\n                    ahook && ahook.call(this);\r\n                };\r\n            })(key)\r\n        });\r\n    });\r\n    _$define(self, '$data', {\r\n        get: function () {\r\n            return _$toPlainObject(this);\r\n        }\r\n    });\r\n}\r\n_$assign(_$BaseComponent[PROP_MAP.h], {\r\n    $get: function (path) {\r\n        return _$accesor(this, path);\r\n    },\r\n    $set: function (path, value) {\r\n        _$accesor(this, path, value);\r\n    },\r\n    $on: function (event, handler) {\r\n        var _this = this;\r\n        if (!this[PROP_MAP.e][event]) {\r\n            this[PROP_MAP.e][event] = [];\r\n        }\r\n        var i = this[PROP_MAP.e][event].push(handler);\r\n        return {\r\n            $off: function () {\r\n                _this[PROP_MAP.e][event].splice(i - 1, 1);\r\n            }\r\n        };\r\n    },\r\n    $once: function (event, handler) {\r\n        var e = this.$on(event, function (args) {\r\n            handler(args);\r\n            e.$off();\r\n        });\r\n    },\r\n    $fire: function (event, data) {\r\n        if (this[PROP_MAP.e][event]) {\r\n            _$each(this[PROP_MAP.e][event], function (handler) { handler(data); });\r\n        }\r\n    },\r\n    $notify: function (key) {\r\n        if (this[PROP_MAP.s][key]) {\r\n            _$each(this[PROP_MAP.s][key], function (suscriber) { suscriber(); });\r\n        }\r\n    },\r\n    $observe: function (deps, listener) {\r\n        var _this = this;\r\n        var subs = [];\r\n        if (_$isArray(deps)) {\r\n            _$each(deps, function (dep) {\r\n                subs.push({ sub: dep, i: _$subscribers.call(_this, dep, listener) });\r\n            });\r\n        }\r\n        else {\r\n            subs.push({ sub: deps, i: _$subscribers.call(this, deps, listener) });\r\n        }\r\n        return {\r\n            $unobserve: function () {\r\n                _$each(subs, function (sub) {\r\n                    _this[PROP_MAP.s][sub.sub].splice(sub.i, 1);\r\n                });\r\n            }\r\n        };\r\n    },\r\n    $watch: function (key, watcher) {\r\n        var _this = this;\r\n        if (!this[PROP_MAP.w][key]) {\r\n            this[PROP_MAP.w][key] = [];\r\n        }\r\n        var i = this[PROP_MAP.w][key].push(watcher.bind(this));\r\n        return {\r\n            $unwatch: function () {\r\n                _this[PROP_MAP.w][key].splice(i - 1, 1);\r\n            }\r\n        };\r\n    }\r\n});\r\nfunction _$Ctor(moduleName, tpl, options) {\r\n    var _a;\r\n    var ctor = (_a = {},\r\n        _a[moduleName] = function (_$attrs, _$parent) {\r\n            _$BaseComponent.call(this, _$attrs, tpl, options, _$parent);\r\n            !_$parent && this.$create();\r\n        },\r\n        _a)[moduleName];\r\n    ctor.plugin = function (fn, options) {\r\n        TPS.push({ options: options, fn: fn });\r\n    };\r\n    _$extends(ctor, _$BaseComponent);\r\n    return ctor;\r\n}\n\n\n//# sourceMappingURL=index.js.map\n\n// EXTERNAL MODULE: h:/trebor-repos/trebor-transitions/node_modules/hash-sum/hash-sum.js\nvar hash_sum = __webpack_require__(\"../../../../trebor-transitions/node_modules/hash-sum/hash-sum.js\");\nvar hash_sum_default = /*#__PURE__*/__webpack_require__.n(hash_sum);\n\n// CONCATENATED MODULE: h:/trebor-repos/trebor-transitions/transition.js\nvar HALF = .5;\r\nvar PI = Math.PI, pow = Math.pow, sin = Math.sin;\r\nvar NEWTON_ITERATIONS = 4;\r\nvar NEWTON_MIN_SLOPE = 0.001;\r\nvar SUBDIVISION_PRECISION = 0.0000001;\r\nvar SUBDIVISION_MAX_ITERATIONS = 10;\r\nvar kSplineTableSize = 11;\r\nvar kSampleStepSize = 1 / (kSplineTableSize - 1);\r\nvar float32ArraySupported = typeof Float32Array === 'function';\r\nfunction C(aA1) { return 3 * aA1; }\r\nfunction now() { return performance.now(); }\r\nfunction B(aA1, aA2) { return C(aA2) - 6 * aA1; }\r\nfunction A(aA1, aA2) { return 1 - C(aA2) + C(aA1); }\r\nfunction calcBezier(aT, aA1, aA2) {\r\n    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\r\n}\r\nfunction getSlope(aT, aA1, aA2) {\r\n    return C(A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1));\r\n}\r\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\r\n    var currentX, currentT, i = 0;\r\n    do {\r\n        currentT = aA + (aB - aA) / 2;\r\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\r\n        if (currentX > 0) {\r\n            aB = currentT;\r\n        }\r\n        else {\r\n            aA = currentT;\r\n        }\r\n    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\r\n    return currentT;\r\n}\r\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\r\n    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\r\n        var currentSlope = getSlope(aGuessT, mX1, mX2);\r\n        if (currentSlope === 0) {\r\n            return aGuessT;\r\n        }\r\n        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\r\n        aGuessT -= currentX / currentSlope;\r\n    }\r\n    return aGuessT;\r\n}\r\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\r\n    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\r\n        throw new Error('bezier x values must be in [0, 1] range');\r\n    }\r\n    if (mX1 === mY1 && mX2 === mY2) {\r\n        return function (x) { return x; };\r\n    }\r\n    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\r\n    for (var i = 0; i < kSplineTableSize; ++i) {\r\n        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\r\n    }\r\n    function getTForX(aX) {\r\n        var currentSample = 1;\r\n        var intervalStart = 0;\r\n        var lastSample = kSplineTableSize - 1;\r\n        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\r\n            intervalStart += kSampleStepSize;\r\n        }\r\n        --currentSample;\r\n        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\r\n        var guessForT = intervalStart + dist * kSampleStepSize;\r\n        var initialSlope = getSlope(guessForT, mX1, mX2);\r\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\r\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\r\n        }\r\n        else if (initialSlope === 0) {\r\n            return guessForT;\r\n        }\r\n        else {\r\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\r\n        }\r\n    }\r\n    return function (x) {\r\n        if (x === 0)\r\n            return 0;\r\n        if (x === 1)\r\n            return 1;\r\n        return calcBezier(getTForX(x), mY1, mY2);\r\n    };\r\n}\r\nfunction bounceOut(t) {\r\n    var c = .9, a = 4 / 11, b = 8 / 11;\r\n    var ca = 4356 / 361, cb = 35442 / 1805, cc = 16061 / 1805, t2 = t * t;\r\n    return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;\r\n}\r\nfunction bounceInOut(t) {\r\n    return t < HALF ? HALF * (1 - bounceOut(1 - t * 2)) : HALF * bounceOut(t * 2 - 1) + HALF;\r\n}\r\nfunction bounceIn(t) {\r\n    return 1 - bounceOut(1 - t);\r\n}\r\nfunction elasticInOut(t) {\r\n    return t < HALF\r\n        ? HALF * sin(13 * PI / 2 * 2 * t) * pow(2, 10 * (2 * t - 1))\r\n        : HALF * sin(-13 * PI / 2 * ((2 * t - 1) + 1)) * pow(2, -10 * (2 * t - 1)) + 1;\r\n}\r\nfunction elasticIn(t) {\r\n    return sin(13 * t * PI / 2) * pow(2, 10 * (t - 1));\r\n}\r\nfunction elasticOut(t) {\r\n    return sin(-13 * (t + 1) * PI / 2) * pow(2, -10 * t) + 1;\r\n}\r\nvar snap = cubicBezier(0, 1, HALF, 1);\r\nvar easeIn = cubicBezier(.42, 0, 1, 1);\r\nvar easeOut = cubicBezier(0, 0, .58, 1);\r\nvar inOut = cubicBezier(.42, 0, .58, 1);\r\nvar linear = cubicBezier(.25, .25, .75, .75);\r\nvar backIn = cubicBezier(.6, -.28, .735, .045);\r\nvar circIn = cubicBezier(.6, .04, .98, .335);\r\nvar cubicIn = cubicBezier(.55, .055, .675, .19);\r\nvar expoIn = cubicBezier(.95, .05, .795, .035);\r\nvar quadIn = cubicBezier(.55, .085, .68, .53);\r\nvar quartIn = cubicBezier(.895, .03, .685, .22);\r\nvar quintIn = cubicBezier(.755, .05, .855, .06);\r\nvar sineIn = cubicBezier(.47, 0, .745, .715);\r\nvar backOut = cubicBezier(.175, .885, .32, 1.275);\r\nvar circOut = cubicBezier(.075, .82, .165, 1);\r\nvar cubicOut = cubicBezier(.215, .61, .355, 1);\r\nvar expoOut = cubicBezier(.19, 1, .22, 1);\r\nvar quadOut = cubicBezier(.25, .46, .45, .94);\r\nvar quartOut = cubicBezier(.165, .84, .44, 1);\r\nvar quintOut = cubicBezier(.23, 1, .32, 1);\r\nvar sineOut = cubicBezier(.39, .575, .565, 1);\r\nvar backInOut = cubicBezier(.68, -.55, .265, 1.55);\r\nvar circInOut = cubicBezier(.785, .135, .15, .86);\r\nvar cubicInOut = cubicBezier(.645, .045, .355, 1);\r\nvar expoInOut = cubicBezier(1, 0, 0, 1);\r\nvar quadInOut = cubicBezier(.455, .03, .515, .955);\r\nvar quartInOut = cubicBezier(.77, 0, .175, 1);\r\nvar quintInOut = cubicBezier(.86, 0, .07, 1);\r\nvar sineInOut = cubicBezier(.445, .05, .55, .95);\r\nfunction transition(_a) {\r\n    var _b = _a.ease, ease = _b === void 0 ? easeIn : _b, duration = _a.duration, _c = _a.loop, loop = _c === void 0 ? false : _c, _d = _a.delay, delay = _d === void 0 ? 0 : _d;\r\n    var diff = 0;\r\n    var start, change, ended;\r\n    function init() {\r\n        start = now();\r\n        !this.running && (this.running = true);\r\n        requestAnimationFrame(animate.bind(this));\r\n    }\r\n    function animate(time) {\r\n        if (this.paused || !change)\r\n            return;\r\n        var fraction = (time - start + diff) / (duration || 800);\r\n        var progress = ease(fraction > 1 ? fraction = 1 : fraction);\r\n        change(progress);\r\n        if (fraction < 1) {\r\n            requestAnimationFrame(animate.bind(this));\r\n        }\r\n        else if (loop) {\r\n            diff = 0;\r\n            init.call(this);\r\n        }\r\n        else {\r\n            this.running = false;\r\n            ended && ended();\r\n        }\r\n    }\r\n    return {\r\n        paused: false,\r\n        running: false,\r\n        on: function (event, handler) {\r\n            event === 'ended' && (ended = handler);\r\n            event === 'change' && (change = handler);\r\n        },\r\n        run: function (d, l) {\r\n            delay = l || delay || 0;\r\n            duration = d || duration || 800;\r\n            delay > 0 ? setTimeout(init.bind(this), delay) : init.call(this);\r\n        },\r\n        pause: function () {\r\n            if (!this.running)\r\n                return;\r\n            this.paused = true;\r\n            diff += now() - start;\r\n        },\r\n        play: function () {\r\n            if (!this.running)\r\n                return;\r\n            this.paused = false;\r\n            init.call(this);\r\n        }\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: h:/trebor-repos/trebor-transitions/tools.js\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\n\r\nfunction animate(options, run) {\r\n    var style = document.querySelector('[animation-style-sheet]');\r\n    if (!style) {\r\n        style = document.createElement('style');\r\n        style.setAttribute('animation-style-sheet', '');\r\n        document.head.appendChild(style);\r\n    }\r\n    var el, styleIndex;\r\n    var styleSheet = style.sheet;\r\n    var className = \"animation_\" + hash_sum_default()(run);\r\n    var _a = __assign({ delay: 0, duration: 400, ease: easeIn }, options), ease = _a.ease, delay = _a.delay, duration = _a.duration;\r\n    var inAnimation = transition({ duration: duration, delay: delay, ease: ease });\r\n    var outAnimation = transition({ duration: duration, delay: delay, ease: function (x) { return 1 - ease(1 - x); } });\r\n    function setChangeCB(node, animation) {\r\n        var args = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            args[_i - 2] = arguments[_i];\r\n        }\r\n        el = node;\r\n        var anime = animation === 'in' ? inAnimation : outAnimation;\r\n        var change = run(node);\r\n        el.classList.add(className);\r\n        anime.on('change', function (progress) {\r\n            styleSheet.cssRules.length && styleSheet.deleteRule(styleIndex);\r\n            var styleTxt = change(animation === 'in' ? progress : 1 - progress);\r\n            styleSheet.insertRule(\".\" + className + \"{\" + styleTxt + \"}\");\r\n            styleIndex = styleSheet.cssRules.length - 1;\r\n        });\r\n        anime.run.apply(anime, args);\r\n    }\r\n    return {\r\n        state: 'in',\r\n        started: false,\r\n        ended: function (handler) {\r\n            var callback = function () {\r\n                el.classList.remove(className);\r\n                handler && handler();\r\n                styleSheet.deleteRule(styleIndex);\r\n            };\r\n            inAnimation.on('ended', callback);\r\n            outAnimation.on('ended', function () {\r\n                callback();\r\n            });\r\n        },\r\n        run: function (node) {\r\n            var args = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                args[_i - 1] = arguments[_i];\r\n            }\r\n            var self = this;\r\n            if (self.state === 'in') {\r\n                self.in.apply(self, [node].concat(args));\r\n                self.state = 'out';\r\n            }\r\n            else {\r\n                self.out.apply(self, [node].concat(args));\r\n                self.state = 'in';\r\n            }\r\n        },\r\n        in: function (node) {\r\n            var args = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                args[_i - 1] = arguments[_i];\r\n            }\r\n            setChangeCB.apply(void 0, [node, 'in'].concat(args));\r\n        },\r\n        out: function (node) {\r\n            var args = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                args[_i - 1] = arguments[_i];\r\n            }\r\n            setChangeCB.apply(void 0, [node, 'out'].concat(args));\r\n        }\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: h:/trebor-repos/trebor-transitions/index.js\nvar trebor_transitions_assign = (undefined && undefined.__assign) || function () {\r\n    trebor_transitions_assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return trebor_transitions_assign.apply(this, arguments);\r\n};\r\n\r\n\r\nfunction FadeAnimation(options) {\r\n    options = options || { delay: 0, duration: 400 };\r\n    return animate(options, function (node) {\r\n        var opacity = +(getComputedStyle(node).opacity || 0);\r\n        return function (progress) { return \"opacity: \" + progress * opacity + \";\"; };\r\n    });\r\n}\r\nfunction FlyAnimation(options) {\r\n    options = options || { delay: 0, duration: 400, x: 0, y: 0, ease: cubicOut };\r\n    return animate(options, function (node) {\r\n        var opacity, transform;\r\n        var _a = trebor_transitions_assign({ x: 0, y: 0 }, options), x = _a.x, y = _a.y;\r\n        var style = getComputedStyle(node);\r\n        opacity = +(style.opacity || 0);\r\n        transform = style.transform === 'none' ? '' : (style.transform ? style.transform + \" \" : '');\r\n        return function (progress) { return \"opacity: \" + progress * opacity + \"; \" +\r\n            (\"transform: \" + transform + \"translate(\" + (1 - progress) * (x || 0) + \"px, \" + (1 - progress) * (y || 0) + \"px);\"); };\r\n    });\r\n}\r\nfunction SlideAnimation(options) {\r\n    options = options || { delay: 0, duration: 400, ease: cubicOut };\r\n    return animate(options, function (node) {\r\n        var opacity, height, paddingTop, paddingBottom, marginTop, marginBottom, borderTopWidth, borderBottomWidth;\r\n        var style = getComputedStyle(node);\r\n        opacity = +(style.opacity || 0);\r\n        height = parseFloat(style.height || '0');\r\n        marginTop = parseFloat(style.marginTop || '0');\r\n        paddingTop = parseFloat(style.paddingTop || '0');\r\n        marginBottom = parseFloat(style.marginBottom || '0');\r\n        paddingBottom = parseFloat(style.paddingBottom || '0');\r\n        borderTopWidth = parseFloat(style.borderTopWidth || '0');\r\n        borderBottomWidth = parseFloat(style.borderBottomWidth || '0');\r\n        return function (progress) { return \"overflow: hidden;\" +\r\n            (\"height: \" + progress * height + \"px;\") +\r\n            (\"margin-top: \" + progress * marginTop + \"px;\") +\r\n            (\"padding-top: \" + progress * paddingTop + \"px;\") +\r\n            (\"margin-bottom: \" + progress * marginBottom + \"px;\") +\r\n            (\"padding-bottom: \" + progress * paddingBottom + \"px;\") +\r\n            (\"border-top-width: \" + progress * borderTopWidth + \"px;\") +\r\n            (\"opacity: \" + Math.min(progress * 20, 1) * opacity + \";\") +\r\n            (\"border-bottom-width: \" + progress * borderBottomWidth + \"px;\"); };\r\n    });\r\n}\r\n\n// CONCATENATED MODULE: ./components/animation.html\n\r\n\r\nfunction ifCondition_1(_$state) {\r\n  var _$frag, div_1, txt_1, _refs;\r\n  _$frag = _$docFragment();\r\n  _refs = _$state.$refs;\r\n  return {\r\n    type: 'if',\r\n\r\n    $create: function() {\r\n      div_1 = _$el();\r\n      txt_1 = _$text('Hello word!');\r\n      _$setReference(_refs, 'box', div_1);\r\n    },\r\n\r\n    $mount: function(parent, sibling) {\r\n      this.$unmount();\r\n      _$append(_$select(parent), _$frag, _$select(sibling));\r\n    },\r\n\r\n    $update: _$noop,\r\n\r\n    $unmount: function() {\r\n      _$append(div_1, txt_1);\r\n      _$append(_$frag, div_1);\r\n    },\r\n\r\n    $destroy: function() {\r\n      this.$unmount();\r\n      _$removeReference(_refs, 'box', div_1);\r\n      _$frag = div_1 = txt_1 = _refs = void 0;\r\n    }\r\n  };\r\n}\r\nfunction condition_1(_$state) {\r\n  if (_$state.visible)\r\n    return ifCondition_1(_$state);\r\n  else\r\n    return _$emptyElse();\r\n}\r\nfunction _$tplAnimation(_$state) {\r\n  var _$frag, input_1, changeEvent_1, handlerChangeEvent_1, label_1, txt_1, setTxt_1, conditionAnchor_1, conditionBlock_1;\r\n  _$frag = _$docFragment();\r\n  changeEvent_1 = function(_$state, $event, $el) {\r\n    _$state.onChange($el.checked);\r\n  };\r\n  setTxt_1 = function() {\r\n    return 'Visible: ';\r\n  };\r\n  '+(_$state.visible)+';\r\n  '';\r\n  conditionAnchor_1 = _$text();\r\n  return {\r\n    $create: function() {\r\n      input_1 = _$el('input');\r\n      label_1 = _$el('label');\r\n      txt_1 = _$text();\r\n      txt_1.data = setTxt_1(_$state);\r\n      conditionBlock_1 = condition_1(_$state);\r\n      conditionBlock_1.$create();\r\n      _$setAttr(input_1, ['id', 'visible']);\r\n      _$setAttr(input_1, ['type', 'checkbox']);\r\n      _$addListener(input_1, 'change', handlerChangeEvent_1 = function(event) {\r\n        changeEvent_1(_$state, event, input_1);\r\n      });\r\n      _$setAttr(label_1, ['for', 'visible']);\r\n    },\r\n\r\n    $mount: function(parent, sibling) {\r\n      this.$unmount();\r\n      _$insertStyle(\r\n        'scope_2d826740',\r\n        'div {width:125px;padding:45px 0;color:white;text-align:center;background-color:black;}'\r\n      );\r\n      _$append(_$select(parent), _$frag, _$select(sibling));\r\n      _$setElements(this, parent, sibling);\r\n    },\r\n\r\n    $update: function(_$state) {\r\n      _$textUpdate(txt_1, setTxt_1(_$state));\r\n      conditionBlock_1 = _$conditionalUpdate(conditionBlock_1, condition_1, undefined, conditionAnchor_1, _$state);\r\n    },\r\n\r\n    $unmount: function() {\r\n      _$append(_$frag, input_1);\r\n      _$append(label_1, txt_1);\r\n      _$append(_$frag, label_1);\r\n      _$append(_$frag, conditionAnchor_1);\r\n      conditionBlock_1.$mount(_$frag, conditionAnchor_1);\r\n    },\r\n\r\n    $destroy: function() {\r\n      _$destroyComponent(this);\r\n      _$removeStyle('scope_2d826740');\r\n      _$removeListener(input_1, 'change', handlerChangeEvent_1);\r\n      conditionBlock_1.$destroy();\r\n      delete _$state.$root;\r\n      _$frag = input_1 = changeEvent_1 = handlerChangeEvent_1 = label_1 = txt_1 = setTxt_1 = conditionAnchor_1 = conditionBlock_1 = void 0;\r\n    }\r\n  };\r\n}\r\nvar animation = SlideAnimation({\r\n  y: 300,\r\n  duration: 1200\r\n});\r\nvar Animation = _$Ctor('Animation', _$tplAnimation, {\r\n  model: {\r\n    visible: false,\r\n\r\n    onChange: function(value) {\r\n      var _this = this;\r\n      var refs = this.$refs;\r\n      animation.ended(function() {\r\n        !value && _this.$update();\r\n      });\r\n      if (value) {\r\n        this.$set('visible', value);\r\n        animation.in(refs.box);\r\n      } else {\r\n        this.visible = value;\r\n        animation.out(refs.box);\r\n      }\r\n    }\r\n  }\r\n});\r\n/* harmony default export */ var components_animation = (Animation);\r\n\n// CONCATENATED MODULE: ./main.ts\n\r\nvar main_animation = new components_animation();\r\nmain_animation.$mount('main');\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vaDovdHJlYm9yLXJlcG9zL3RyZWJvci10b29scy9pbmRleC5qcz82NjBlIiwid2VicGFjazovLy9oOi90cmVib3ItcmVwb3MvdHJlYm9yLXRyYW5zaXRpb25zL3RyYW5zaXRpb24uanM/NzkzMiIsIndlYnBhY2s6Ly8vaDovdHJlYm9yLXJlcG9zL3RyZWJvci10cmFuc2l0aW9ucy90b29scy5qcz9hY2UyIiwid2VicGFjazovLy9oOi90cmVib3ItcmVwb3MvdHJlYm9yLXRyYW5zaXRpb25zL2luZGV4LmpzPzllYjMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9hbmltYXRpb24uaHRtbD9jZDA4Iiwid2VicGFjazovLy8uL21haW4udHM/ODI2OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixxQ0FBcUMsYUFBYTtBQUNsRCxzQ0FBc0MsY0FBYztBQUNwRDtBQUNBO0FBQ0EsdUNBQXVDLHFCQUFxQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFD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O0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDYyxrRUFBUyxFQUFDOzs7QUNqSjJCO0FBRXBELElBQU0sY0FBUyxHQUFHLElBQUksb0JBQVMsRUFBRSxDQUFDO0FBRWxDLGNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMiLCJmaWxlIjoiLi9tYWluLnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIFBST1BTID0gWyckc2xvdHMnLCAnJHJlZnMnLCAnJGZpbHRlcnMnLCAnJGRpcmVjdGl2ZXMnLCAnX2V2ZW50cycsICdfd2F0Y2hlcnMnXTtcclxudmFyIFBST1BfTUFQID0geyBwOiAnX19UUF9fJywgdjogJ3ZhbHVlJywgXzogJ192YWx1ZScsIHM6ICdfc3Vic2NyaWJlcnMnLCBlOiAnX2V2ZW50cycsIHc6ICdfd2F0Y2hlcnMnLCBoOiAncHJvdG90eXBlJyB9O1xyXG52YXIgVFBTID0gd2luZG93W1BST1BfTUFQLnBdIHx8ICh3aW5kb3dbUFJPUF9NQVAucF0gPSBbXSk7XG5cbnZhciBhcnJheSA9IEFycmF5W1BST1BfTUFQLmhdO1xyXG5mdW5jdGlvbiBfJHRvQXJncyhhcmdzLCBzdGFydCkge1xyXG4gICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSAwOyB9XHJcbiAgICByZXR1cm4gYXJyYXkuc2xpY2UuY2FsbChhcmdzLCBzdGFydCk7XHJcbn1cclxuZnVuY3Rpb24gXyRhcnJheVZhbHVlcyhsaXN0LCB2YWx1ZSwgcm9vdCwga2V5KSB7XHJcbiAgICBhcnJheS5wdXNoLmFwcGx5KGxpc3QsIHZhbHVlLm1hcChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCAhPT0gMClcclxuICAgICAgICAgICAgaSArPSBsaXN0Lmxlbmd0aDtcclxuICAgICAgICByZXR1cm4gIShfJGlzVHlwZSh2LCBfJExpc3QpKSAmJiBfJGlzQXJyYXkodikgPyBuZXcgXyRMaXN0KHYsIHJvb3QsIGtleSArIFwiLlwiICsgaSkgOiB2O1xyXG4gICAgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIF8kTGlzdCh2YWx1ZSwgcm9vdCwga2V5KSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICBBcnJheS5hcHBseShzZWxmLCBbdmFsdWUubGVuZ3RoXSk7XHJcbiAgICB2YXIgZGVzYyA9IHsgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IGZhbHNlLCBlbnVtZXJhYmxlOiBmYWxzZSB9O1xyXG4gICAgXyRkZWZpbmUoc2VsZiwgJ19rZXknLCBfJGFzc2lnbih7IHZhbHVlOiBrZXkgfSwgZGVzYykpO1xyXG4gICAgXyRkZWZpbmUoc2VsZiwgJ19yb290JywgXyRhc3NpZ24oeyB2YWx1ZTogcm9vdCB9LCBkZXNjKSk7XHJcbiAgICBfJGFycmF5VmFsdWVzKHNlbGYsIHZhbHVlLCByb290LCBrZXkpO1xyXG4gICAgZGVzYy53cml0YWJsZSA9IHRydWU7XHJcbiAgICBfJGRlZmluZShzZWxmLCAnbGVuZ3RoJywgXyRhc3NpZ24oeyB2YWx1ZTogc2VsZi5sZW5ndGggfSwgZGVzYykpO1xyXG59XHJcbl8kZXh0ZW5kcyhfJExpc3QsIEFycmF5KTtcclxuWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnZmlsbCcsICd1bnNoaWZ0JywgJ3NwbGljZSddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gICAgXyRMaXN0W1BST1BfTUFQLmhdW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBvbGQgPSBzZWxmLnNsaWNlKCk7XHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICBpZiAobWV0aG9kID09PSAncHVzaCcpIHtcclxuICAgICAgICAgICAgXyRhcnJheVZhbHVlcyhzZWxmLCBfJHRvQXJncyhhcmd1bWVudHMpLCBzZWxmLl9yb290LCBzZWxmLl9rZXkpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSBzZWxmLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGFycmF5W21ldGhvZF0uYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXyRkaXNwYXRjaChzZWxmLl9yb290LCBzZWxmLl9rZXksIG9sZCwgc2VsZi5zbGljZSgpKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxufSk7XHJcbl8kTGlzdFtQUk9QX01BUC5oXS5wdWxsID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgaXRlbXMgPSBfJHRvQXJncyhhcmd1bWVudHMsIDEpO1xyXG4gICAgdmFyIGxlbmd0aCA9IHNlbGYubGVuZ3RoO1xyXG4gICAgaWYgKGluZGV4ID4gbGVuZ3RoKSB7XHJcbiAgICAgICAgbGVuZ3RoID0gaW5kZXggKyAxO1xyXG4gICAgICAgIHZhciBwdWxsID0gbmV3IEFycmF5KGluZGV4IC0gc2VsZi5sZW5ndGgpO1xyXG4gICAgICAgIHB1bGwucHVzaC5hcHBseShwdWxsLCBpdGVtcyk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYucHVzaC5hcHBseShzZWxmLCBwdWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtpbmRleCwgMV0uY29uY2F0KGl0ZW1zKSk7XHJcbiAgICB9XHJcbn07XG5cbmZ1bmN0aW9uIF8kc2VsZWN0KHNlbGVjdG9yLCBwYXJlbnQpIHtcclxuICAgIHJldHVybiBfJGlzU3RyaW5nKHNlbGVjdG9yKSA/IChwYXJlbnQgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpIDogc2VsZWN0b3I7XHJcbn1cclxuZnVuY3Rpb24gXyRkb2NGcmFnbWVudCgpIHtcclxuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbn1cclxuZnVuY3Rpb24gXyRhcHBlbmQocGFyZW50LCBjaGlsZCwgc2libGluZykge1xyXG4gICAgaWYgKF8kaXNUeXBlKHNpYmxpbmcsICdib29sZWFuJykgJiYgc2libGluZylcclxuICAgICAgICBwYXJlbnQucGFyZW50RWxlbWVudC5yZXBsYWNlQ2hpbGQoY2hpbGQsIHBhcmVudCk7XHJcbiAgICBlbHNlIGlmICghc2libGluZylcclxuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHNpYmxpbmcpO1xyXG59XHJcbmZ1bmN0aW9uIF8kYXNzaWduRWwoc291cmNlLCBkZXN0KSB7XHJcbiAgICB2YXIgY2hpbGROb2RlcyA9IHNvdXJjZS5jaGlsZE5vZGVzLCBhdHRyaWJ1dGVzID0gc291cmNlLmF0dHJpYnV0ZXM7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBfJGFwcGVuZChkZXN0LCBjaGlsZE5vZGVzW2ldKTtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBhdHRyID0gYXR0cmlidXRlc1tpXTtcclxuICAgICAgICBkZXN0LnNldEF0dHJpYnV0ZU5TKHNvdXJjZS5uYW1lc3BhY2VVUkksIGF0dHIubmFtZSwgYXR0ci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBzb3VyY2UucGFyZW50RWxlbWVudC5yZXBsYWNlQ2hpbGQoZGVzdCwgc291cmNlKTtcclxuICAgIHJldHVybiBkZXN0O1xyXG59XHJcbmZ1bmN0aW9uIF8kcmVtb3ZlRWwoZWwsIHBhcmVudCkge1xyXG4gICAgdmFyIHJvb3QgPSBwYXJlbnQgfHwgZWwucGFyZW50RWxlbWVudDtcclxuICAgIGlmIChyb290KVxyXG4gICAgICAgIHJvb3QucmVtb3ZlQ2hpbGQoZWwpO1xyXG59XHJcbmZ1bmN0aW9uIF8kZWwodGFnTmFtZSkge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSB8fCAnZGl2Jyk7XHJcbn1cclxuZnVuY3Rpb24gXyRzdmcodGFnTmFtZSkge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCB0YWdOYW1lIHx8ICdzdmcnKTtcclxufVxyXG5mdW5jdGlvbiBfJHRleHQoY29udGVudCkge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbnRlbnQgfHwgJycpO1xyXG59XHJcbmZ1bmN0aW9uIF8kY29tbWVudChjb250ZW50KSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChjb250ZW50IHx8ICcnKTtcclxufVxyXG5mdW5jdGlvbiBfJHNldEF0dHIoZWwsIGF0dHJBbmRWYWx1ZSkge1xyXG4gICAgdmFyIGF0dHIgPSBhdHRyQW5kVmFsdWVbMF0sIHZhbHVlID0gYXR0ckFuZFZhbHVlWzFdO1xyXG4gICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIF8kdG9TdHJpbmcodmFsdWUpKTtcclxuICAgIGlmIChfJGlzVmFsdWVBdHRyKGF0dHIpICYmICFfJGlzU3RyaW5nKHZhbHVlKSlcclxuICAgICAgICBlbFtQUk9QX01BUC5fXSA9IHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIF8kZ2V0QXR0cihlbCwgYXR0cikge1xyXG4gICAgcmV0dXJuIF8kaXNWYWx1ZUF0dHIoYXR0cikgPyBfJGdldFZhbHVlKGVsKSA6IGVsLmdldEF0dHJpYnV0ZShhdHRyKTtcclxufVxyXG5mdW5jdGlvbiBfJGdldFZhbHVlKGVsKSB7XHJcbiAgICByZXR1cm4gXyRoYXNQcm9wKGVsLCBQUk9QX01BUC5fKSA/IGVsW1BST1BfTUFQLl9dIDogZWxbUFJPUF9NQVAudl07XHJcbn1cclxuZnVuY3Rpb24gXyRhZGRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIpIHtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGZhbHNlKTtcclxufVxyXG5mdW5jdGlvbiBfJHVwZGF0ZUxpc3RlbmVyKGVsLCBldmVudCwgb2xkSGFuZGxlciwgbmV3SGFuZGxlcikge1xyXG4gICAgXyRyZW1vdmVMaXN0ZW5lcihlbCwgZXZlbnQsIG9sZEhhbmRsZXIpO1xyXG4gICAgXyRhZGRMaXN0ZW5lcihlbCwgZXZlbnQsIG9sZEhhbmRsZXIgPSBuZXdIYW5kbGVyKTtcclxuICAgIHJldHVybiBvbGRIYW5kbGVyO1xyXG59XHJcbmZ1bmN0aW9uIF8kcmVtb3ZlTGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyKSB7XHJcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBmYWxzZSk7XHJcbn1cclxuZnVuY3Rpb24gXyRiaW5kR3JvdXAoaW5wdXQsIHNlbGVjdGlvbikge1xyXG4gICAgdmFyIF92YWx1ZSA9IF8kZ2V0VmFsdWUoaW5wdXQpO1xyXG4gICAgdmFyIF8kaW5kZXggPSBzZWxlY3Rpb24uaW5kZXhPZihfdmFsdWUpO1xyXG4gICAgaW5wdXQuY2hlY2tlZCAmJiAhfl8kaW5kZXggPyBzZWxlY3Rpb24ucHVzaChfdmFsdWUpIDogc2VsZWN0aW9uLnNwbGljZShfJGluZGV4LCAxKTtcclxufVxyXG5mdW5jdGlvbiBfJGJpbmRNdWx0aVNlbGVjdChzZWxlY3QsIHNlbGVjdGlvbnMpIHtcclxuICAgIGlmICghc2VsZWN0aW9ucy5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdmFyIG9wdGlvbnMgPSBzZWxlY3Qub3B0aW9ucztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSAhIX5zZWxlY3Rpb25zLmluZGV4T2YoXyRnZXRWYWx1ZShvcHRpb25zW2ldKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gXyR1cGRhdGVNdWx0aVNlbGVjdChzZWxlY3QsIG9iaiwgcHJvcCkge1xyXG4gICAgdmFyIGl0ZW1zID0gW107XHJcbiAgICB2YXIgc2VsZWN0aW9uID0gb2JqW3Byb3BdO1xyXG4gICAgdmFyIHNlbGVjdGVkT3B0aW9ucyA9IHNlbGVjdC5zZWxlY3RlZE9wdGlvbnM7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkT3B0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGl0ZW1zLnB1c2goXyRnZXRWYWx1ZShzZWxlY3RlZE9wdGlvbnNbaV0pKTtcclxuICAgIH1cclxuICAgIG9ialtwcm9wXSA9IG5ldyBfJExpc3QoaXRlbXMsIHNlbGVjdGlvblsnX3Jvb3QnXSwgc2VsZWN0aW9uWydfa2V5J10pO1xyXG4gICAgb2JqLiR1cGRhdGUoKTtcclxufVxyXG5mdW5jdGlvbiBfJGluc2VydFN0eWxlKGlkLCBjc3MpIHtcclxuICAgIHZhciBpc05ldyA9IGZhbHNlO1xyXG4gICAgdmFyIHN0eWxlID0gXyRzZWxlY3QoXCIjXCIgKyBpZCwgZG9jdW1lbnQuaGVhZCk7XHJcbiAgICBpZiAoIXN0eWxlKSB7XHJcbiAgICAgICAgaXNOZXcgPSB0cnVlO1xyXG4gICAgICAgIHN0eWxlID0gXyRlbCgnc3R5bGUnKTtcclxuICAgICAgICBzdHlsZS5pZCA9IGlkO1xyXG4gICAgICAgIF8kc2V0QXR0cihzdHlsZSwgWydyZWZzJywgMV0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0eWxlLnRleHRDb250ZW50ICE9PSBjc3MpIHtcclxuICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IGNzcztcclxuICAgIH1cclxuICAgIGlmIChpc05ldykge1xyXG4gICAgICAgIF8kYXBwZW5kKGRvY3VtZW50LmhlYWQsIHN0eWxlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBjb3VudCA9ICtfJGdldEF0dHIoc3R5bGUsICdyZWZzJyk7XHJcbiAgICAgICAgXyRzZXRBdHRyKHN0eWxlLCBbJ3JlZnMnLCArK2NvdW50XSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gXyRyZW1vdmVTdHlsZShpZCkge1xyXG4gICAgdmFyIHN0eWxlID0gXyRzZWxlY3QoXCIjXCIgKyBpZCwgZG9jdW1lbnQuaGVhZCk7XHJcbiAgICBpZiAoc3R5bGUpIHtcclxuICAgICAgICB2YXIgY291bnQgPSArXyRnZXRBdHRyKHN0eWxlLCAncmVmcycpO1xyXG4gICAgICAgIGlmICgtLWNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIF8kcmVtb3ZlRWwoc3R5bGUsIGRvY3VtZW50LmhlYWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgXyRzZXRBdHRyKHN0eWxlLCBbJ3JlZnMnLCBjb3VudF0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBfJHRvTG93ZXJDYXNlKHN0cikge1xyXG4gICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpO1xyXG59XHJcbnZhciBfJGFzc2lnbiA9IE9iamVjdFsnYXNzaWduJ10gfHwgZnVuY3Rpb24gKHQpIHtcclxuICAgIGZvciAodmFyIHMgPSB2b2lkIDAsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKVxyXG4gICAgICAgICAgICBpZiAoXyRoYXNQcm9wKHMsIHApKVxyXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufTtcclxuZnVuY3Rpb24gXyRhcHBseShjYWxsZWUsIGFyZ3MsIGdsb2JzLCB0aGlzQXJnKSB7XHJcbiAgICBpZiAodGhpc0FyZyA9PT0gdm9pZCAwKSB7IHRoaXNBcmcgPSBudWxsOyB9XHJcbiAgICByZXR1cm4gY2FsbGVlLmFwcGx5KHRoaXNBcmcsIGFyZ3MuY29uY2F0KGdsb2JzKSk7XHJcbn1cclxuZnVuY3Rpb24gXyRpc1ZhbHVlQXR0cihhdHRyKSB7XHJcbiAgICByZXR1cm4gYXR0ciA9PT0gJ3ZhbHVlJztcclxufVxyXG5mdW5jdGlvbiBfJHN1YnNjcmliZXJzKGRlcCwgbGlzdGVuZXIpIHtcclxuICAgIGlmICghdGhpc1tQUk9QX01BUC5zXVtkZXBdKSB7XHJcbiAgICAgICAgdGhpc1tQUk9QX01BUC5zXVtkZXBdID0gW107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpc1tQUk9QX01BUC5zXVtkZXBdLnB1c2gobGlzdGVuZXIuYmluZCh0aGlzKSkgLSAxO1xyXG59XHJcbmZ1bmN0aW9uIF8kZGVmaW5lKG9iaiwga2V5LCBkZXNjKSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIGRlc2MpO1xyXG59XHJcbmZ1bmN0aW9uIF8kZGlzcGF0Y2gocm9vdCwga2V5LCBvbGRWYWwsIHZhbHVlKSB7XHJcbiAgICByb290LiRub3RpZnkoa2V5KTtcclxuICAgIGlmIChyb290W1BST1BfTUFQLnddW2tleV0pIHtcclxuICAgICAgICBfJGVhY2gocm9vdFtQUk9QX01BUC53XVtrZXldLCBmdW5jdGlvbiAod2F0Y2hlcikgeyB3YXRjaGVyKG9sZFZhbCwgdmFsdWUpOyB9KTtcclxuICAgIH1cclxuICAgIHJvb3QuJHVwZGF0ZSgpO1xyXG59XHJcbmZ1bmN0aW9uIF8kZXh0ZW5kcyhjdG9yLCBleHRzKSB7XHJcbiAgICBjdG9yW1BST1BfTUFQLmhdID0gT2JqZWN0LmNyZWF0ZShleHRzW1BST1BfTUFQLmhdKTtcclxuICAgIGN0b3JbUFJPUF9NQVAuaF0uY29uc3RydWN0b3IgPSBjdG9yO1xyXG59XHJcbmZ1bmN0aW9uIF8kaXNUeXBlKHZhbHVlLCB0eXBlKSB7XHJcbiAgICByZXR1cm4gXyR0eXBlKHR5cGUpID09PSAnc3RyaW5nJyA/IHR5cGUuc3BsaXQoJ1xcfCcpLnNvbWUoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQudHJpbSgpID09PSBfJHR5cGUodmFsdWUpOyB9KSA6IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcclxufVxyXG5mdW5jdGlvbiBfJGlzT2JqZWN0KG9iaikge1xyXG4gICAgcmV0dXJuIF8kaXNUeXBlKG9iaiwgJ29iamVjdCcpO1xyXG59XHJcbmZ1bmN0aW9uIF8kaXNBcnJheShvYmopIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5ID8gQXJyYXkuaXNBcnJheShvYmopIDogXyRpc1R5cGUob2JqLCAnYXJyYXknKTtcclxufVxyXG5mdW5jdGlvbiBfJGlzRnVuY3Rpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gXyRpc1R5cGUob2JqLCAnZnVuY3Rpb24nKTtcclxufVxyXG5mdW5jdGlvbiBfJGlzU3RyaW5nKG9iaikge1xyXG4gICAgcmV0dXJuIF8kaXNUeXBlKG9iaiwgJ3N0cmluZycpO1xyXG59XHJcbmZ1bmN0aW9uIF8kdG9UeXBlKHZhbHVlLCB0eXBlLCByb290LCBrZXkpIHtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ2RhdGUnOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xyXG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgICAgIHJldHVybiBfJHRvU3RyaW5nKHZhbHVlKTtcclxuICAgICAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICAgICAgICByZXR1cm4gK3ZhbHVlO1xyXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgICAgICAgICByZXR1cm4gXyRpc1N0cmluZyh2YWx1ZSkgJiYgIXZhbHVlID8gdHJ1ZSA6ICEhdmFsdWU7XHJcbiAgICAgICAgY2FzZSAnYXJyYXknOlxyXG4gICAgICAgICAgICByZXR1cm4gXyRpc1R5cGUodmFsdWUsIF8kTGlzdCkgPyB2YWx1ZSA6IG5ldyBfJExpc3QodmFsdWUsIHJvb3QsIGtleSk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIF8kdHlwZShvYmopIHtcclxuICAgIHJldHVybiBfJHRvTG93ZXJDYXNlKC8gKFxcdyspLy5leGVjKHt9LnRvU3RyaW5nLmNhbGwob2JqKSlbMV0pO1xyXG59XHJcbmZ1bmN0aW9uIF8kaGFzUHJvcChvYmosIHByb3ApIHtcclxuICAgIHJldHVybiBvYmouaGFzT3duUHJvcGVydHkocHJvcCk7XHJcbn1cclxuZnVuY3Rpb24gXyRkaXJlY3RpdmUoZGQpIHtcclxuICAgIHZhciBoYXNQcm9wID0gZnVuY3Rpb24gKHByb3AsIGluc3RhbmNlLCBvcHRpb25zLCBlbGVtZW50KSB7IHJldHVybiBfJGlzT2JqZWN0KGRkKSAmJiBkZFtwcm9wXSAmJiBkZFtwcm9wXShpbnN0YW5jZSwgb3B0aW9ucywgZWxlbWVudCk7IH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgICRpbml0OiBmdW5jdGlvbiAoaW5zdGFuY2UsIG9wdGlvbnMsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaGFzUHJvcCgnJGluaXQnLCBpbnN0YW5jZSwgb3B0aW9ucywgZWxlbWVudCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAkaW5zZXJ0ZWQ6IGZ1bmN0aW9uIChpbnN0YW5jZSwgb3B0aW9ucywgZWxlbWVudCkge1xyXG4gICAgICAgICAgICBoYXNQcm9wKCckaW5zZXJ0ZWQnLCBpbnN0YW5jZSwgb3B0aW9ucywgZWxlbWVudCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAkdXBkYXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG9wdGlvbnMsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKF8kaXNGdW5jdGlvbihkZCkpIHtcclxuICAgICAgICAgICAgICAgIGRkKGluc3RhbmNlLCBvcHRpb25zLCBlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhhc1Byb3AoJyR1cGRhdGUnLCBpbnN0YW5jZSwgb3B0aW9ucywgZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICRkZXN0cm95OiBmdW5jdGlvbiAoaW5zdGFuY2UsIG9wdGlvbnMsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaGFzUHJvcCgnJGRlc3Ryb3knLCBpbnN0YW5jZSwgb3B0aW9ucywgZWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBfJG5vb3AoKSB7IH1cclxuZnVuY3Rpb24gXyRhZGRDaGlsZChpbnN0LCBDaGlsZCwgYXR0cnMpIHtcclxuICAgIHZhciBjaGlsZCA9IG51bGw7XHJcbiAgICBpZiAoQ2hpbGQpIHtcclxuICAgICAgICBjaGlsZCA9IG5ldyBDaGlsZChhdHRycywgaW5zdCk7XHJcbiAgICAgICAgaW5zdC4kY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2hpbGQ7XHJcbn1cclxuZnVuY3Rpb24gXyRyZW1vdmVDaGlsZChpbnN0LCBjaGlsZCkge1xyXG4gICAgdmFyIGluZGV4ID0gaW5zdC4kY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XHJcbiAgICBpbmRleCA+PSAwICYmIGluc3QuJGNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XHJcbn1cclxuZnVuY3Rpb24gXyR0b1N0cmluZyhvYmopIHtcclxuICAgIHZhciBzdHIgPSBfJHR5cGUob2JqKTtcclxuICAgIHJldHVybiAhL251bGx8dW5kZWZpbmVkLy50ZXN0KHN0cikgPyBvYmoudG9TdHJpbmcoKSA6IHN0cjtcclxufVxyXG5mdW5jdGlvbiBfJHRvUGxhaW5PYmplY3Qob2JqKSB7XHJcbiAgICB2YXIgZGF0YSA9IHt9O1xyXG4gICAgXyRlYWNoKF8kaXNPYmplY3Qob2JqKSA/IG9iaiA6IHt9LCBmdW5jdGlvbiAoX3YsIGspIHtcclxuICAgICAgICBpZiAoa1swXSAhPT0gJyQnICYmICFfJGlzRnVuY3Rpb24ob2JqW2tdKSkge1xyXG4gICAgICAgICAgICBpZiAoXyRpc1R5cGUob2JqW2tdLCBfJExpc3QpKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhW2tdID0gb2JqW2tdLm1hcChfJHRvUGxhaW5PYmplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF8kaXNPYmplY3Qob2JqW2tdKSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YVtrXSA9IF8kdG9QbGFpbk9iamVjdChvYmpba10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGF0YVtrXSA9IG9ialtrXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIF8kaXNPYmplY3Qob2JqKSA/IGRhdGEgOiBvYmo7XHJcbn1cclxuZnVuY3Rpb24gXyRzZXRSZWZlcmVuY2UocmVmcywgcHJvcCwgbm9kZSkge1xyXG4gICAgaWYgKCFfJGhhc1Byb3AocmVmcywgcHJvcCkpIHtcclxuICAgICAgICB2YXIgdmFsdWVfMSA9IFtdO1xyXG4gICAgICAgIF8kZGVmaW5lKHJlZnMsIHByb3AsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZV8xLmxlbmd0aCA8PSAxID8gdmFsdWVfMVswXSA6IHZhbHVlXzE7IH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB2YWwgJiYgIX52YWx1ZV8xLmluZGV4T2YodmFsKSAmJiB2YWx1ZV8xLnB1c2godmFsKTsgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZWZzW3Byb3BdID0gbm9kZTtcclxufVxyXG5mdW5jdGlvbiBfJGFjY2Vzb3Iob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHBhdGguc3BsaXQoJy4nKS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwga2V5LCBpLCBhcnIpIHtcclxuICAgICAgICBpZiAoXyRpc1R5cGUodmFsdWUsICd1bmRlZmluZWQnKSkge1xyXG4gICAgICAgICAgICBpZiAob2JqID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGFyci5zcGxpY2UoMCwgYXJyLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA+IDAgJiYgb2JqID09PSBudWxsID8gb2JqIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gYXJyLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfJGlzVHlwZShvYmosIF8kTGlzdCkgJiYgXyR0b1N0cmluZygra2V5KSA9PT0ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqLnB1bGwoK2tleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFZhbCA9IG9ialtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gIV8kaXNUeXBlKHZhbHVlLCBfJExpc3QpICYmIF8kaXNBcnJheSh2YWx1ZSkgPyBuZXcgXyRMaXN0KHZhbHVlLCBvYmplY3QsIGtleSkgOiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBfJGRpc3BhdGNoKG9iamVjdCwgcGF0aCwgb2xkVmFsLCBvYmpba2V5XSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIV8kaXNPYmplY3Qob2JqW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmogPyBvYmpba2V5XSA6IG51bGw7XHJcbiAgICB9LCBvYmplY3QpO1xyXG59XHJcbmZ1bmN0aW9uIF8kZW1wdHlFbHNlKCkge1xyXG4gICAgcmV0dXJuIHsgdHlwZTogJ2VtcHR5LWVsc2UnLCAkY3JlYXRlOiBfJG5vb3AsICRtb3VudDogXyRub29wLCAkdXBkYXRlOiBfJG5vb3AsICRkZXN0cm95OiBfJG5vb3AgfTtcclxufVxyXG5mdW5jdGlvbiBfJGlzS2V5KGV2ZW50LCBrZXkpIHtcclxuICAgIHJldHVybiBfJHRvTG93ZXJDYXNlKGV2ZW50LmtleSkgPT09IGtleSB8fCAhIWV2ZW50W2tleSArIFwiS2V5XCJdO1xyXG59XHJcbmZ1bmN0aW9uIF8kYmluZENsYXNzZXModmFsdWUpIHtcclxuICAgIHZhciBjbGFzc2VzID0gJyc7XHJcbiAgICBpZiAoXyRpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICBjbGFzc2VzICs9IFwiIFwiICsgdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChfJGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgY2xhc3NlcyA9IHZhbHVlLm1hcChfJGJpbmRDbGFzc2VzKS5qb2luKCcgJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChfJGlzT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSlcclxuICAgICAgICAgICAgaWYgKF8kaGFzUHJvcCh2YWx1ZSwga2V5KSAmJiB2YWx1ZVtrZXldKVxyXG4gICAgICAgICAgICAgICAgY2xhc3NlcyArPSBcIiBcIiArIGtleTtcclxuICAgIH1cclxuICAgIHJldHVybiBjbGFzc2VzLnRyaW0oKTtcclxufVxyXG5mdW5jdGlvbiBfJGJpbmRTdHlsZSh2YWx1ZSkge1xyXG4gICAgdmFyIGVsID0gXyRlbCgpO1xyXG4gICAgaWYgKF8kaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgdmFyIHN0eWxlXzEgPSBlbC5zdHlsZTtcclxuICAgICAgICBfJGVhY2godmFsdWUsIGZ1bmN0aW9uICh2YWwsIHByb3ApIHtcclxuICAgICAgICAgICAgaWYgKHZhbCAhPT0gc3R5bGVfMVtwcm9wXSlcclxuICAgICAgICAgICAgICAgIHN0eWxlXzFbcHJvcF0gPSB2YWw7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHN0eWxlXzEuY3NzVGV4dDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKF8kaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIF8kY29uZGl0aW9uYWxVcGRhdGUoYmxvY2ssIGNvbmRpdGlvbiwgcGFyZW50LCBhbmNob3IsIGluc3QpIHtcclxuICAgIHZhciBnbG9icyA9IF8kdG9BcmdzKGFyZ3VtZW50cywgNSk7XHJcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2sudHlwZSA9PT0gXyRhcHBseShjb25kaXRpb24sIFtpbnN0XSwgZ2xvYnMpLnR5cGUpIHtcclxuICAgICAgICBfJGFwcGx5KGJsb2NrLiR1cGRhdGUsIFtpbnN0XSwgZ2xvYnMsIGJsb2NrKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGJsb2NrICYmIGJsb2NrLiRkZXN0cm95KCk7XHJcbiAgICAgICAgYmxvY2sgPSBfJGFwcGx5KGNvbmRpdGlvbiwgW2luc3RdLCBnbG9icyk7XHJcbiAgICAgICAgYmxvY2suJGNyZWF0ZSgpO1xyXG4gICAgICAgIGJsb2NrLiRtb3VudChwYXJlbnQgfHwgaW5zdC4kcGFyZW50RWwsIGFuY2hvcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYmxvY2s7XHJcbn1cclxuZnVuY3Rpb24gXyRiaW5kVXBkYXRlKGVsLCBiaW5kaW5nKSB7XHJcbiAgICB2YXIgYXR0ciA9IGJpbmRpbmdbMF0sIHZhbHVlID0gYmluZGluZ1sxXTtcclxuICAgIHZhciBfdmFsdWUgPSBfJHRvU3RyaW5nKHZhbHVlKTtcclxuICAgIGlmIChfJGlzVmFsdWVBdHRyKGF0dHIpKSB7XHJcbiAgICAgICAgaWYgKGVsW2F0dHJdICE9PSBfdmFsdWUpXHJcbiAgICAgICAgICAgIGVsW2F0dHJdID0gX3ZhbHVlO1xyXG4gICAgICAgIGVsW1BST1BfTUFQLl9dID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChfJGdldEF0dHIoZWwsIGF0dHIpICE9PSBfdmFsdWUpIHtcclxuICAgICAgICBfJHNldEF0dHIoZWwsIFthdHRyLCBfdmFsdWVdKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBfJGJpbmRCb29sZWFuQXR0cihlbCwgYXR0ckFuZFZhbHVlKSB7XHJcbiAgICB2YXIgYXR0ciA9IGF0dHJBbmRWYWx1ZVswXSwgdmFsdWUgPSBhdHRyQW5kVmFsdWVbMV07XHJcbiAgICBlbFthdHRyXSA9IHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09IGZhbHNlID8gKGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKSwgZmFsc2UpIDogKF8kc2V0QXR0cihlbCwgW2F0dHIsICcnXSksIHRydWUpO1xyXG59XHJcbmZ1bmN0aW9uIF8kdGV4dFVwZGF0ZSh0ZXh0LCB2YWx1ZSkge1xyXG4gICAgaWYgKHRleHQuZGF0YSAhPT0gKHZhbHVlID0gXyR0b1N0cmluZyh2YWx1ZSkpKVxyXG4gICAgICAgIHRleHQuZGF0YSA9IHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIF8kdGFnVXBkYXRlKG5vZGUsIHRhZykge1xyXG4gICAgcmV0dXJuIF8kdG9Mb3dlckNhc2UodGFnKSAhPT0gXyR0b0xvd2VyQ2FzZShub2RlLnRhZ05hbWUpID8gXyRhc3NpZ25FbChub2RlLCBfJGVsKHRhZykpIDogbm9kZTtcclxufVxyXG5mdW5jdGlvbiBfJHJlbW92ZVJlZmVyZW5jZShyZWZzLCBwcm9wLCBub2RlKSB7XHJcbiAgICB2YXIgbm9kZXMgPSByZWZzW3Byb3BdO1xyXG4gICAgXyRpc0FycmF5KG5vZGVzKSA/IHJlZnNbcHJvcF0uc3BsaWNlKG5vZGVzLmluZGV4T2Yobm9kZSksIDEpIDogKGRlbGV0ZSByZWZzW3Byb3BdKTtcclxufVxyXG5mdW5jdGlvbiBfJGh0bWxVcGRhdGUobm9kZSwgdmFsdWUpIHtcclxuICAgIGlmIChub2RlLmlubmVySFRNTCAhPT0gKHZhbHVlID0gXyR0b1N0cmluZyh2YWx1ZSkpKVxyXG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gdmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gXyRjb21wb25lbnRVcGRhdGUocGFyZW50LCBDdG9yLCBpbnN0LCB2YWx1ZSwgYXR0cnMsIGVsLCBzaWJsaW5nKSB7XHJcbiAgICBpZiAodmFsdWUgPT09IEN0b3IpIHtcclxuICAgICAgICBpbnN0ICYmIGluc3QuJHVwZGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgQ3RvciA9IHZhbHVlO1xyXG4gICAgICAgIGlmIChpbnN0KSB7XHJcbiAgICAgICAgICAgIGluc3QuJGRlc3Ryb3koKTtcclxuICAgICAgICAgICAgXyRyZW1vdmVDaGlsZChwYXJlbnQsIGluc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5zdCkge1xyXG4gICAgICAgICAgICBpbnN0ID0gXyRhZGRDaGlsZChwYXJlbnQsIEN0b3IsIGF0dHJzKTtcclxuICAgICAgICAgICAgaW5zdC4kY3JlYXRlKCk7XHJcbiAgICAgICAgICAgIGluc3QuJG1vdW50KGVsLCBzaWJsaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW2luc3QsIEN0b3JdO1xyXG59XHJcbmZ1bmN0aW9uIF8kZGVzdHJveUNvbXBvbmVudChjb21wb25lbnQpIHtcclxuICAgIGNvbXBvbmVudC4kdW5tb3VudCgpO1xyXG4gICAgY29tcG9uZW50LiRwYXJlbnQgPSBudWxsO1xyXG4gICAgY29tcG9uZW50LiRwYXJlbnRFbCA9IG51bGw7XHJcbiAgICBjb21wb25lbnQuJHNpYmxpbmdFbCA9IG51bGw7XHJcbiAgICBjb21wb25lbnQuJGNoaWxkcmVuLnNwbGljZSgwLCBjb21wb25lbnQuJGNoaWxkcmVuLmxlbmd0aCk7XHJcbn1cclxuZnVuY3Rpb24gXyRzZXRFbGVtZW50cyhjb21wb25lbnQsIHBhcmVudCwgc2libGluZykge1xyXG4gICAgdmFyIGJyb3RoZXIgPSBfJHNlbGVjdChzaWJsaW5nKTtcclxuICAgIGNvbXBvbmVudC4kc2libGluZ0VsID0gYnJvdGhlcjtcclxuICAgIGNvbXBvbmVudC4kcGFyZW50RWwgPSBzaWJsaW5nICYmIGJyb3RoZXIucGFyZW50RWxlbWVudCB8fCBfJHNlbGVjdChwYXJlbnQpO1xyXG59XHJcbmZ1bmN0aW9uIF8kZm9yTG9vcChyb290LCBvYmosIGxvb3ApIHtcclxuICAgIHZhciBpdGVtcyA9IHt9LCBsb29wUGFyZW50LCBsb29wU2libGluZztcclxuICAgIHZhciBnbG9icyA9IF8kdG9BcmdzKGFyZ3VtZW50cywgMyk7XHJcbiAgICBfJGVhY2gob2JqLCBmdW5jdGlvbiAoaXRlbSwgaSwgaW5kZXgpIHsgaXRlbXNbaV0gPSBfJGFwcGx5KGxvb3AsIFtyb290LCBpdGVtLCBpLCBpbmRleF0sIGdsb2JzKTsgfSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgICRjcmVhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgXyRlYWNoKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkgeyBpdGVtLiRjcmVhdGUoKTsgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAkbW91bnQ6IGZ1bmN0aW9uIChwYXJlbnQsIHNpYmxpbmcpIHtcclxuICAgICAgICAgICAgbG9vcFBhcmVudCA9IF8kc2VsZWN0KHBhcmVudCk7XHJcbiAgICAgICAgICAgIGxvb3BTaWJsaW5nID0gXyRzZWxlY3Qoc2libGluZyk7XHJcbiAgICAgICAgICAgIF8kZWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHsgaXRlbS4kbW91bnQobG9vcFBhcmVudCwgbG9vcFNpYmxpbmcpOyB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgICR1cGRhdGU6IGZ1bmN0aW9uIChyb290LCBvYmopIHtcclxuICAgICAgICAgICAgdmFyIGdsb2JzID0gXyR0b0FyZ3MoYXJndW1lbnRzLCAyKTtcclxuICAgICAgICAgICAgXyRlYWNoKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSwgaSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvYmpbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBfJGFwcGx5KGl0ZW0uJHVwZGF0ZSwgW3Jvb3QsIG9ialtpXSwgaSwgaW5kZXhdLCBnbG9icywgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLiRkZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW1zW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgXyRlYWNoKG9iaiwgZnVuY3Rpb24gKGl0ZW0sIGksIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1zW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0gPSBfJGFwcGx5KGxvb3AsIFtyb290LCBpdGVtLCBpLCBpbmRleF0sIGdsb2JzKTtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXS4kY3JlYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0uJG1vdW50KGxvb3BQYXJlbnQsIGxvb3BTaWJsaW5nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAkZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfJGVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7IGl0ZW0uJGRlc3Ryb3koKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBfJGVhY2gob2JqLCBjYikge1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xyXG4gICAgICAgIGlmIChfJGhhc1Byb3Aob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIGNiKG9ialtrZXldLCAoaXNOYU4oK2tleSkgPyBrZXkgOiAra2V5KSwgaSsrKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gXyRCYXNlQ29tcG9uZW50KGF0dHJzLCB0ZW1wbGF0ZSwgb3B0aW9ucywgcGFyZW50KSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgXyRzZXQgPSBmdW5jdGlvbiAocHJvcCwgdmFsdWUpIHsgXyRkZWZpbmUoc2VsZiwgcHJvcCwgeyB2YWx1ZTogdmFsdWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9O1xyXG4gICAgaWYgKCFhdHRycylcclxuICAgICAgICBhdHRycyA9IHt9O1xyXG4gICAgXyRlYWNoKFBST1BTLCBmdW5jdGlvbiAocHJvcCkgeyBfJGRlZmluZShzZWxmLCBwcm9wLCB7IHZhbHVlOiB7fSB9KTsgfSk7XHJcbiAgICBfJHNldCgnJHBhcmVudCcsIHBhcmVudCB8fCBudWxsKTtcclxuICAgIF8kc2V0KCckY2hpbGRyZW4nLCBbXSk7XHJcbiAgICBfJHNldChQUk9QX01BUC5zLCB7fSk7XHJcbiAgICBfJHNldCgnJG9wdGlvbnMnLCBvcHRpb25zKTtcclxuICAgIHZhciBvcHRzID0gc2VsZi4kb3B0aW9ucztcclxuICAgIGlmICghb3B0cy5hdHRycylcclxuICAgICAgICBvcHRzLmF0dHJzID0ge307XHJcbiAgICBpZiAoIW9wdHMuY2hpbGRyZW4pXHJcbiAgICAgICAgb3B0cy5jaGlsZHJlbiA9IHt9O1xyXG4gICAgXyRlYWNoKFRQUywgZnVuY3Rpb24gKHBsdWdpbikgeyBwbHVnaW4uZm4uY2FsbChzZWxmLCBfJEJhc2VDb21wb25lbnQsIHBsdWdpbi5vcHRpb25zKTsgfSk7XHJcbiAgICBpZiAob3B0cy5maWx0ZXJzKVxyXG4gICAgICAgIF8kYXNzaWduKHNlbGYuJGZpbHRlcnMsIG9wdHMuZmlsdGVycyk7XHJcbiAgICBpZiAob3B0cy5kaXJlY3RpdmVzKVxyXG4gICAgICAgIF8kZWFjaChvcHRzLmRpcmVjdGl2ZXMsIGZ1bmN0aW9uIChkcnQsIGspIHsgc2VsZi4kZGlyZWN0aXZlc1trXSA9IF8kZGlyZWN0aXZlKGRydCk7IH0pO1xyXG4gICAgXyRlYWNoKG9wdHMuYXR0cnMsIGZ1bmN0aW9uIChhdHRyT3BzLCBrZXkpIHtcclxuICAgICAgICBfJGRlZmluZShzZWxmLCAoXyRpc1R5cGUoa2V5LCAnbnVtYmVyJykgPyBhdHRyT3BzIDoga2V5KSwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfJGlzU3RyaW5nKGF0dHJPcHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbYXR0ck9wc107XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8kaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSgpIDogdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIV8kaGFzUHJvcChhdHRycywga2V5KSAmJiBhdHRyT3BzLnJlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiQXR0cmlidXRlICdcIiArIGtleSArIFwiJyBpcyByZXF1aXJlZC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBfJGlzRnVuY3Rpb24oYXR0cnNba2V5XSkgPyBhdHRyc1trZXldKCkgOiBhdHRyc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCAmJiBfJGhhc1Byb3AoYXR0ck9wcywgJ2RlZmF1bHQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZiA9IGF0dHJPcHMuZGVmYXVsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gXyRpc0Z1bmN0aW9uKGRlZikgPyBkZWYoKSA6IGRlZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwID0gYXR0ck9wcy50eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwICYmICFfJGlzVHlwZSh2YWx1ZSwgdHlwKSAmJiBhdHRyT3BzLnJlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkF0dHJpYnV0ZSAnXCIgKyBrZXkgKyBcIicgbXVzdCBiZSB0eXBlICdcIiArIHR5cCArIFwiJy5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfJHRvVHlwZSh2YWx1ZSwgdmFsdWUgPT09IHZvaWQgMCA/ICd1bmRlZmluZWQnIDogdHlwLCBzZWxmLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCAmJiBfJGhhc1Byb3AoYXR0ck9wcywgJ3ZhbGlkYXRvcicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdG9yID0gYXR0ck9wcy52YWxpZGF0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXyRpc0Z1bmN0aW9uKHZhbGlkYXRvcikgJiYgIXZhbGlkYXRvcih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkFzc2lnbWVudCAnXCIgKyBrZXkgKyBcIic9J1wiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgXCInIGludmFsaWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIidcIiArIGtleSArIFwiJyBpcyByZWFkIG9ubHkuXCIpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgdmFyIGRhdGEgPSBvcHRzLm1vZGVsIHx8IHt9O1xyXG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgaWYgKF8kaGFzUHJvcChkYXRhLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkYXRhLCBrZXkpO1xyXG4gICAgICAgICAgICBpZiAoZGVzYy52YWx1ZSAmJiBfJGlzQXJyYXkoZGVzYy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGRlc2MudmFsdWUgPSBuZXcgXyRMaXN0KGRlc2MudmFsdWUsIHNlbGYsIGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0dGVyXzEgPSBkZXNjLmdldDtcclxuICAgICAgICAgICAgICAgICAgICBkZXNjLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyXzEuY2FsbChzZWxmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF8kaXNBcnJheSh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBfJExpc3QodmFsdWUsIHNlbGYsIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRlc2Muc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNldHRlcl8xID0gZGVzYy5zZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVzYy5zZXQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXyRpc0FycmF5KHYpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IG5ldyBfJExpc3Qodiwgc2VsZiwga2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyXzEuY2FsbChzZWxmLCB2KTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF8kZGVmaW5lKHNlbGYsIGtleSwgZGVzYyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XHJcbiAgICAgICAgX2xvb3BfMShrZXkpO1xyXG4gICAgfVxyXG4gICAgdmFyIHRwbCA9IHRlbXBsYXRlKHNlbGYpO1xyXG4gICAgXyRlYWNoKHRwbCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICBfJGRlZmluZShzZWxmLCBrZXksIHtcclxuICAgICAgICAgICAgdmFsdWU6IChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaG9vayA9IGtleVsxXS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJob29rID0gb3B0c1tcIndpbGxcIiArIGhvb2tdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFob29rID0gb3B0c1tcImRpZFwiICsgaG9va107XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJob29rICYmIGJob29rLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID09PSAnJHVwZGF0ZScgPyB2YWx1ZS5jYWxsKHRoaXMsIHRoaXMpIDogdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICBhaG9vayAmJiBhaG9vay5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSkoa2V5KVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICBfJGRlZmluZShzZWxmLCAnJGRhdGEnLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfJHRvUGxhaW5PYmplY3QodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXyRhc3NpZ24oXyRCYXNlQ29tcG9uZW50W1BST1BfTUFQLmhdLCB7XHJcbiAgICAkZ2V0OiBmdW5jdGlvbiAocGF0aCkge1xyXG4gICAgICAgIHJldHVybiBfJGFjY2Vzb3IodGhpcywgcGF0aCk7XHJcbiAgICB9LFxyXG4gICAgJHNldDogZnVuY3Rpb24gKHBhdGgsIHZhbHVlKSB7XHJcbiAgICAgICAgXyRhY2Nlc29yKHRoaXMsIHBhdGgsIHZhbHVlKTtcclxuICAgIH0sXHJcbiAgICAkb246IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCF0aGlzW1BST1BfTUFQLmVdW2V2ZW50XSkge1xyXG4gICAgICAgICAgICB0aGlzW1BST1BfTUFQLmVdW2V2ZW50XSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaSA9IHRoaXNbUFJPUF9NQVAuZV1bZXZlbnRdLnB1c2goaGFuZGxlcik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJG9mZjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXNbUFJPUF9NQVAuZV1bZXZlbnRdLnNwbGljZShpIC0gMSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgICRvbmNlOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgZSA9IHRoaXMuJG9uKGV2ZW50LCBmdW5jdGlvbiAoYXJncykge1xyXG4gICAgICAgICAgICBoYW5kbGVyKGFyZ3MpO1xyXG4gICAgICAgICAgICBlLiRvZmYoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICAkZmlyZTogZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKHRoaXNbUFJPUF9NQVAuZV1bZXZlbnRdKSB7XHJcbiAgICAgICAgICAgIF8kZWFjaCh0aGlzW1BST1BfTUFQLmVdW2V2ZW50XSwgZnVuY3Rpb24gKGhhbmRsZXIpIHsgaGFuZGxlcihkYXRhKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgICRub3RpZnk6IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICBpZiAodGhpc1tQUk9QX01BUC5zXVtrZXldKSB7XHJcbiAgICAgICAgICAgIF8kZWFjaCh0aGlzW1BST1BfTUFQLnNdW2tleV0sIGZ1bmN0aW9uIChzdXNjcmliZXIpIHsgc3VzY3JpYmVyKCk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAkb2JzZXJ2ZTogZnVuY3Rpb24gKGRlcHMsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgc3VicyA9IFtdO1xyXG4gICAgICAgIGlmIChfJGlzQXJyYXkoZGVwcykpIHtcclxuICAgICAgICAgICAgXyRlYWNoKGRlcHMsIGZ1bmN0aW9uIChkZXApIHtcclxuICAgICAgICAgICAgICAgIHN1YnMucHVzaCh7IHN1YjogZGVwLCBpOiBfJHN1YnNjcmliZXJzLmNhbGwoX3RoaXMsIGRlcCwgbGlzdGVuZXIpIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN1YnMucHVzaCh7IHN1YjogZGVwcywgaTogXyRzdWJzY3JpYmVycy5jYWxsKHRoaXMsIGRlcHMsIGxpc3RlbmVyKSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJHVub2JzZXJ2ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgXyRlYWNoKHN1YnMsIGZ1bmN0aW9uIChzdWIpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpc1tQUk9QX01BUC5zXVtzdWIuc3ViXS5zcGxpY2Uoc3ViLmksIDEpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgICR3YXRjaDogZnVuY3Rpb24gKGtleSwgd2F0Y2hlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCF0aGlzW1BST1BfTUFQLnddW2tleV0pIHtcclxuICAgICAgICAgICAgdGhpc1tQUk9QX01BUC53XVtrZXldID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpID0gdGhpc1tQUk9QX01BUC53XVtrZXldLnB1c2god2F0Y2hlci5iaW5kKHRoaXMpKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAkdW53YXRjaDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXNbUFJPUF9NQVAud11ba2V5XS5zcGxpY2UoaSAtIDEsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufSk7XHJcbmZ1bmN0aW9uIF8kQ3Rvcihtb2R1bGVOYW1lLCB0cGwsIG9wdGlvbnMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHZhciBjdG9yID0gKF9hID0ge30sXHJcbiAgICAgICAgX2FbbW9kdWxlTmFtZV0gPSBmdW5jdGlvbiAoXyRhdHRycywgXyRwYXJlbnQpIHtcclxuICAgICAgICAgICAgXyRCYXNlQ29tcG9uZW50LmNhbGwodGhpcywgXyRhdHRycywgdHBsLCBvcHRpb25zLCBfJHBhcmVudCk7XHJcbiAgICAgICAgICAgICFfJHBhcmVudCAmJiB0aGlzLiRjcmVhdGUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9hKVttb2R1bGVOYW1lXTtcclxuICAgIGN0b3IucGx1Z2luID0gZnVuY3Rpb24gKGZuLCBvcHRpb25zKSB7XHJcbiAgICAgICAgVFBTLnB1c2goeyBvcHRpb25zOiBvcHRpb25zLCBmbjogZm4gfSk7XHJcbiAgICB9O1xyXG4gICAgXyRleHRlbmRzKGN0b3IsIF8kQmFzZUNvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gY3RvcjtcclxufVxuXG5leHBvcnQgeyBfJHJlbW92ZUNoaWxkLCBfJGJpbmRHcm91cCwgXyRlbXB0eUVsc2UsIF8kQ3RvciwgXyRiaW5kTXVsdGlTZWxlY3QsIF8kc2V0QXR0ciwgXyRyZW1vdmVFbCwgXyRhc3NpZ25FbCwgXyRlbCwgXyRiaW5kU3R5bGUsIF8kZm9yTG9vcCwgXyRlYWNoLCBfJGluc2VydFN0eWxlLCBfJHJlbW92ZVN0eWxlLCBfJGdldEF0dHIsIF8kYWRkTGlzdGVuZXIsIF8kdXBkYXRlTGlzdGVuZXIsIF8kcmVtb3ZlTGlzdGVuZXIsIF8kYmluZENsYXNzZXMsIF8kZGVzdHJveUNvbXBvbmVudCwgXyRzdmcsIF8kbm9vcCwgXyR0b1N0cmluZywgXyRzZXRSZWZlcmVuY2UsIF8kaXNUeXBlLCBfJGlzS2V5LCBfJHNlbGVjdCwgXyRkb2NGcmFnbWVudCwgXyRhcHBlbmQsIF8kdXBkYXRlTXVsdGlTZWxlY3QsIF8kY29tcG9uZW50VXBkYXRlLCBfJGh0bWxVcGRhdGUsIF8kdGFnVXBkYXRlLCBfJGJpbmRCb29sZWFuQXR0ciwgXyRyZW1vdmVSZWZlcmVuY2UsIF8kYWRkQ2hpbGQsIF8kdGV4dFVwZGF0ZSwgXyRnZXRWYWx1ZSwgXyR0ZXh0LCBfJGNvbmRpdGlvbmFsVXBkYXRlLCBfJGJpbmRVcGRhdGUsIF8kY29tbWVudCwgXyRzZXRFbGVtZW50cyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJ2YXIgSEFMRiA9IC41O1xyXG52YXIgUEkgPSBNYXRoLlBJLCBwb3cgPSBNYXRoLnBvdywgc2luID0gTWF0aC5zaW47XHJcbnZhciBORVdUT05fSVRFUkFUSU9OUyA9IDQ7XHJcbnZhciBORVdUT05fTUlOX1NMT1BFID0gMC4wMDE7XHJcbnZhciBTVUJESVZJU0lPTl9QUkVDSVNJT04gPSAwLjAwMDAwMDE7XHJcbnZhciBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwO1xyXG52YXIga1NwbGluZVRhYmxlU2l6ZSA9IDExO1xyXG52YXIga1NhbXBsZVN0ZXBTaXplID0gMSAvIChrU3BsaW5lVGFibGVTaXplIC0gMSk7XHJcbnZhciBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAnZnVuY3Rpb24nO1xyXG5mdW5jdGlvbiBDKGFBMSkgeyByZXR1cm4gMyAqIGFBMTsgfVxyXG5mdW5jdGlvbiBub3coKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfVxyXG5mdW5jdGlvbiBCKGFBMSwgYUEyKSB7IHJldHVybiBDKGFBMikgLSA2ICogYUExOyB9XHJcbmZ1bmN0aW9uIEEoYUExLCBhQTIpIHsgcmV0dXJuIDEgLSBDKGFBMikgKyBDKGFBMSk7IH1cclxuZnVuY3Rpb24gY2FsY0JlemllcihhVCwgYUExLCBhQTIpIHtcclxuICAgIHJldHVybiAoKEEoYUExLCBhQTIpICogYVQgKyBCKGFBMSwgYUEyKSkgKiBhVCArIEMoYUExKSkgKiBhVDtcclxufVxyXG5mdW5jdGlvbiBnZXRTbG9wZShhVCwgYUExLCBhQTIpIHtcclxuICAgIHJldHVybiBDKEEoYUExLCBhQTIpICogYVQgKiBhVCArIDIgKiBCKGFBMSwgYUEyKSAqIGFUICsgQyhhQTEpKTtcclxufVxyXG5mdW5jdGlvbiBiaW5hcnlTdWJkaXZpZGUoYVgsIGFBLCBhQiwgbVgxLCBtWDIpIHtcclxuICAgIHZhciBjdXJyZW50WCwgY3VycmVudFQsIGkgPSAwO1xyXG4gICAgZG8ge1xyXG4gICAgICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyO1xyXG4gICAgICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRYID4gMCkge1xyXG4gICAgICAgICAgICBhQiA9IGN1cnJlbnRUO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYUEgPSBjdXJyZW50VDtcclxuICAgICAgICB9XHJcbiAgICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBTVUJESVZJU0lPTl9QUkVDSVNJT04gJiYgKytpIDwgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMpO1xyXG4gICAgcmV0dXJuIGN1cnJlbnRUO1xyXG59XHJcbmZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NULCBtWDEsIG1YMikge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBORVdUT05fSVRFUkFUSU9OUzsgKytpKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRTbG9wZSA9IGdldFNsb3BlKGFHdWVzc1QsIG1YMSwgbVgyKTtcclxuICAgICAgICBpZiAoY3VycmVudFNsb3BlID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhR3Vlc3NUO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xyXG4gICAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYUd1ZXNzVDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY3ViaWNCZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XHJcbiAgICBpZiAoISgwIDw9IG1YMSAmJiBtWDEgPD0gMSAmJiAwIDw9IG1YMiAmJiBtWDIgPD0gMSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JlemllciB4IHZhbHVlcyBtdXN0IGJlIGluIFswLCAxXSByYW5nZScpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9O1xyXG4gICAgfVxyXG4gICAgdmFyIHNhbXBsZVZhbHVlcyA9IGZsb2F0MzJBcnJheVN1cHBvcnRlZCA/IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSkgOiBuZXcgQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xyXG4gICAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0VEZvclgoYVgpIHtcclxuICAgICAgICB2YXIgY3VycmVudFNhbXBsZSA9IDE7XHJcbiAgICAgICAgdmFyIGludGVydmFsU3RhcnQgPSAwO1xyXG4gICAgICAgIHZhciBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XHJcbiAgICAgICAgZm9yICg7IGN1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcclxuICAgICAgICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC0tY3VycmVudFNhbXBsZTtcclxuICAgICAgICB2YXIgZGlzdCA9IChhWCAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAoc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSk7XHJcbiAgICAgICAgdmFyIGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICoga1NhbXBsZVN0ZXBTaXplO1xyXG4gICAgICAgIHZhciBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcclxuICAgICAgICBpZiAoaW5pdGlhbFNsb3BlID49IE5FV1RPTl9NSU5fU0xPUEUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQsIG1YMSwgbVgyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW5pdGlhbFNsb3BlID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBndWVzc0ZvclQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYmluYXJ5U3ViZGl2aWRlKGFYLCBpbnRlcnZhbFN0YXJ0LCBpbnRlcnZhbFN0YXJ0ICsga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgaWYgKHggPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIGlmICh4ID09PSAxKVxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICByZXR1cm4gY2FsY0JlemllcihnZXRURm9yWCh4KSwgbVkxLCBtWTIpO1xyXG4gICAgfTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gYm91bmNlT3V0KHQpIHtcclxuICAgIHZhciBjID0gLjksIGEgPSA0IC8gMTEsIGIgPSA4IC8gMTE7XHJcbiAgICB2YXIgY2EgPSA0MzU2IC8gMzYxLCBjYiA9IDM1NDQyIC8gMTgwNSwgY2MgPSAxNjA2MSAvIDE4MDUsIHQyID0gdCAqIHQ7XHJcbiAgICByZXR1cm4gdCA8IGEgPyA3LjU2MjUgKiB0MiA6IHQgPCBiID8gOS4wNzUgKiB0MiAtIDkuOSAqIHQgKyAzLjQgOiB0IDwgYyA/IGNhICogdDIgLSBjYiAqIHQgKyBjYyA6IDEwLjggKiB0ICogdCAtIDIwLjUyICogdCArIDEwLjcyO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBib3VuY2VJbk91dCh0KSB7XHJcbiAgICByZXR1cm4gdCA8IEhBTEYgPyBIQUxGICogKDEgLSBib3VuY2VPdXQoMSAtIHQgKiAyKSkgOiBIQUxGICogYm91bmNlT3V0KHQgKiAyIC0gMSkgKyBIQUxGO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBib3VuY2VJbih0KSB7XHJcbiAgICByZXR1cm4gMSAtIGJvdW5jZU91dCgxIC0gdCk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGVsYXN0aWNJbk91dCh0KSB7XHJcbiAgICByZXR1cm4gdCA8IEhBTEZcclxuICAgICAgICA/IEhBTEYgKiBzaW4oMTMgKiBQSSAvIDIgKiAyICogdCkgKiBwb3coMiwgMTAgKiAoMiAqIHQgLSAxKSlcclxuICAgICAgICA6IEhBTEYgKiBzaW4oLTEzICogUEkgLyAyICogKCgyICogdCAtIDEpICsgMSkpICogcG93KDIsIC0xMCAqICgyICogdCAtIDEpKSArIDE7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGVsYXN0aWNJbih0KSB7XHJcbiAgICByZXR1cm4gc2luKDEzICogdCAqIFBJIC8gMikgKiBwb3coMiwgMTAgKiAodCAtIDEpKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZWxhc3RpY091dCh0KSB7XHJcbiAgICByZXR1cm4gc2luKC0xMyAqICh0ICsgMSkgKiBQSSAvIDIpICogcG93KDIsIC0xMCAqIHQpICsgMTtcclxufVxyXG5leHBvcnQgdmFyIHNuYXAgPSBjdWJpY0JlemllcigwLCAxLCBIQUxGLCAxKTtcclxuZXhwb3J0IHZhciBlYXNlSW4gPSBjdWJpY0JlemllciguNDIsIDAsIDEsIDEpO1xyXG5leHBvcnQgdmFyIGVhc2VPdXQgPSBjdWJpY0JlemllcigwLCAwLCAuNTgsIDEpO1xyXG5leHBvcnQgdmFyIGluT3V0ID0gY3ViaWNCZXppZXIoLjQyLCAwLCAuNTgsIDEpO1xyXG5leHBvcnQgdmFyIGxpbmVhciA9IGN1YmljQmV6aWVyKC4yNSwgLjI1LCAuNzUsIC43NSk7XHJcbmV4cG9ydCB2YXIgYmFja0luID0gY3ViaWNCZXppZXIoLjYsIC0uMjgsIC43MzUsIC4wNDUpO1xyXG5leHBvcnQgdmFyIGNpcmNJbiA9IGN1YmljQmV6aWVyKC42LCAuMDQsIC45OCwgLjMzNSk7XHJcbmV4cG9ydCB2YXIgY3ViaWNJbiA9IGN1YmljQmV6aWVyKC41NSwgLjA1NSwgLjY3NSwgLjE5KTtcclxuZXhwb3J0IHZhciBleHBvSW4gPSBjdWJpY0JlemllciguOTUsIC4wNSwgLjc5NSwgLjAzNSk7XHJcbmV4cG9ydCB2YXIgcXVhZEluID0gY3ViaWNCZXppZXIoLjU1LCAuMDg1LCAuNjgsIC41Myk7XHJcbmV4cG9ydCB2YXIgcXVhcnRJbiA9IGN1YmljQmV6aWVyKC44OTUsIC4wMywgLjY4NSwgLjIyKTtcclxuZXhwb3J0IHZhciBxdWludEluID0gY3ViaWNCZXppZXIoLjc1NSwgLjA1LCAuODU1LCAuMDYpO1xyXG5leHBvcnQgdmFyIHNpbmVJbiA9IGN1YmljQmV6aWVyKC40NywgMCwgLjc0NSwgLjcxNSk7XHJcbmV4cG9ydCB2YXIgYmFja091dCA9IGN1YmljQmV6aWVyKC4xNzUsIC44ODUsIC4zMiwgMS4yNzUpO1xyXG5leHBvcnQgdmFyIGNpcmNPdXQgPSBjdWJpY0JlemllciguMDc1LCAuODIsIC4xNjUsIDEpO1xyXG5leHBvcnQgdmFyIGN1YmljT3V0ID0gY3ViaWNCZXppZXIoLjIxNSwgLjYxLCAuMzU1LCAxKTtcclxuZXhwb3J0IHZhciBleHBvT3V0ID0gY3ViaWNCZXppZXIoLjE5LCAxLCAuMjIsIDEpO1xyXG5leHBvcnQgdmFyIHF1YWRPdXQgPSBjdWJpY0JlemllciguMjUsIC40NiwgLjQ1LCAuOTQpO1xyXG5leHBvcnQgdmFyIHF1YXJ0T3V0ID0gY3ViaWNCZXppZXIoLjE2NSwgLjg0LCAuNDQsIDEpO1xyXG5leHBvcnQgdmFyIHF1aW50T3V0ID0gY3ViaWNCZXppZXIoLjIzLCAxLCAuMzIsIDEpO1xyXG5leHBvcnQgdmFyIHNpbmVPdXQgPSBjdWJpY0JlemllciguMzksIC41NzUsIC41NjUsIDEpO1xyXG5leHBvcnQgdmFyIGJhY2tJbk91dCA9IGN1YmljQmV6aWVyKC42OCwgLS41NSwgLjI2NSwgMS41NSk7XHJcbmV4cG9ydCB2YXIgY2lyY0luT3V0ID0gY3ViaWNCZXppZXIoLjc4NSwgLjEzNSwgLjE1LCAuODYpO1xyXG5leHBvcnQgdmFyIGN1YmljSW5PdXQgPSBjdWJpY0JlemllciguNjQ1LCAuMDQ1LCAuMzU1LCAxKTtcclxuZXhwb3J0IHZhciBleHBvSW5PdXQgPSBjdWJpY0JlemllcigxLCAwLCAwLCAxKTtcclxuZXhwb3J0IHZhciBxdWFkSW5PdXQgPSBjdWJpY0JlemllciguNDU1LCAuMDMsIC41MTUsIC45NTUpO1xyXG5leHBvcnQgdmFyIHF1YXJ0SW5PdXQgPSBjdWJpY0JlemllciguNzcsIDAsIC4xNzUsIDEpO1xyXG5leHBvcnQgdmFyIHF1aW50SW5PdXQgPSBjdWJpY0JlemllciguODYsIDAsIC4wNywgMSk7XHJcbmV4cG9ydCB2YXIgc2luZUluT3V0ID0gY3ViaWNCZXppZXIoLjQ0NSwgLjA1LCAuNTUsIC45NSk7XHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zaXRpb24oX2EpIHtcclxuICAgIHZhciBfYiA9IF9hLmVhc2UsIGVhc2UgPSBfYiA9PT0gdm9pZCAwID8gZWFzZUluIDogX2IsIGR1cmF0aW9uID0gX2EuZHVyYXRpb24sIF9jID0gX2EubG9vcCwgbG9vcCA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLCBfZCA9IF9hLmRlbGF5LCBkZWxheSA9IF9kID09PSB2b2lkIDAgPyAwIDogX2Q7XHJcbiAgICB2YXIgZGlmZiA9IDA7XHJcbiAgICB2YXIgc3RhcnQsIGNoYW5nZSwgZW5kZWQ7XHJcbiAgICBmdW5jdGlvbiBpbml0KCkge1xyXG4gICAgICAgIHN0YXJ0ID0gbm93KCk7XHJcbiAgICAgICAgIXRoaXMucnVubmluZyAmJiAodGhpcy5ydW5uaW5nID0gdHJ1ZSk7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUuYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhbmltYXRlKHRpbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5wYXVzZWQgfHwgIWNoYW5nZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBmcmFjdGlvbiA9ICh0aW1lIC0gc3RhcnQgKyBkaWZmKSAvIChkdXJhdGlvbiB8fCA4MDApO1xyXG4gICAgICAgIHZhciBwcm9ncmVzcyA9IGVhc2UoZnJhY3Rpb24gPiAxID8gZnJhY3Rpb24gPSAxIDogZnJhY3Rpb24pO1xyXG4gICAgICAgIGNoYW5nZShwcm9ncmVzcyk7XHJcbiAgICAgICAgaWYgKGZyYWN0aW9uIDwgMSkge1xyXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobG9vcCkge1xyXG4gICAgICAgICAgICBkaWZmID0gMDtcclxuICAgICAgICAgICAgaW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGVuZGVkICYmIGVuZGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwYXVzZWQ6IGZhbHNlLFxyXG4gICAgICAgIHJ1bm5pbmc6IGZhbHNlLFxyXG4gICAgICAgIG9uOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgZXZlbnQgPT09ICdlbmRlZCcgJiYgKGVuZGVkID0gaGFuZGxlcik7XHJcbiAgICAgICAgICAgIGV2ZW50ID09PSAnY2hhbmdlJyAmJiAoY2hhbmdlID0gaGFuZGxlcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBydW46IGZ1bmN0aW9uIChkLCBsKSB7XHJcbiAgICAgICAgICAgIGRlbGF5ID0gbCB8fCBkZWxheSB8fCAwO1xyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IGQgfHwgZHVyYXRpb24gfHwgODAwO1xyXG4gICAgICAgICAgICBkZWxheSA+IDAgPyBzZXRUaW1lb3V0KGluaXQuYmluZCh0aGlzKSwgZGVsYXkpIDogaW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnJ1bm5pbmcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgZGlmZiArPSBub3coKSAtIHN0YXJ0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGxheTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucnVubmluZylcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgaW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxyXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5pbXBvcnQgaGFzaCBmcm9tICdoYXNoLXN1bSc7XHJcbmltcG9ydCB0cmFuc2l0aW9uLCB7IGVhc2VJbiB9IGZyb20gJy4vdHJhbnNpdGlvbic7XHJcbmV4cG9ydCBmdW5jdGlvbiBhbmltYXRlKG9wdGlvbnMsIHJ1bikge1xyXG4gICAgdmFyIHN0eWxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2FuaW1hdGlvbi1zdHlsZS1zaGVldF0nKTtcclxuICAgIGlmICghc3R5bGUpIHtcclxuICAgICAgICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XHJcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCdhbmltYXRpb24tc3R5bGUtc2hlZXQnLCAnJyk7XHJcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XHJcbiAgICB9XHJcbiAgICB2YXIgZWwsIHN0eWxlSW5kZXg7XHJcbiAgICB2YXIgc3R5bGVTaGVldCA9IHN0eWxlLnNoZWV0O1xyXG4gICAgdmFyIGNsYXNzTmFtZSA9IFwiYW5pbWF0aW9uX1wiICsgaGFzaChydW4pO1xyXG4gICAgdmFyIF9hID0gX19hc3NpZ24oeyBkZWxheTogMCwgZHVyYXRpb246IDQwMCwgZWFzZTogZWFzZUluIH0sIG9wdGlvbnMpLCBlYXNlID0gX2EuZWFzZSwgZGVsYXkgPSBfYS5kZWxheSwgZHVyYXRpb24gPSBfYS5kdXJhdGlvbjtcclxuICAgIHZhciBpbkFuaW1hdGlvbiA9IHRyYW5zaXRpb24oeyBkdXJhdGlvbjogZHVyYXRpb24sIGRlbGF5OiBkZWxheSwgZWFzZTogZWFzZSB9KTtcclxuICAgIHZhciBvdXRBbmltYXRpb24gPSB0cmFuc2l0aW9uKHsgZHVyYXRpb246IGR1cmF0aW9uLCBkZWxheTogZGVsYXksIGVhc2U6IGZ1bmN0aW9uICh4KSB7IHJldHVybiAxIC0gZWFzZSgxIC0geCk7IH0gfSk7XHJcbiAgICBmdW5jdGlvbiBzZXRDaGFuZ2VDQihub2RlLCBhbmltYXRpb24pIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsID0gbm9kZTtcclxuICAgICAgICB2YXIgYW5pbWUgPSBhbmltYXRpb24gPT09ICdpbicgPyBpbkFuaW1hdGlvbiA6IG91dEFuaW1hdGlvbjtcclxuICAgICAgICB2YXIgY2hhbmdlID0gcnVuKG5vZGUpO1xyXG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcclxuICAgICAgICBhbmltZS5vbignY2hhbmdlJywgZnVuY3Rpb24gKHByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgIHN0eWxlU2hlZXQuY3NzUnVsZXMubGVuZ3RoICYmIHN0eWxlU2hlZXQuZGVsZXRlUnVsZShzdHlsZUluZGV4KTtcclxuICAgICAgICAgICAgdmFyIHN0eWxlVHh0ID0gY2hhbmdlKGFuaW1hdGlvbiA9PT0gJ2luJyA/IHByb2dyZXNzIDogMSAtIHByb2dyZXNzKTtcclxuICAgICAgICAgICAgc3R5bGVTaGVldC5pbnNlcnRSdWxlKFwiLlwiICsgY2xhc3NOYW1lICsgXCJ7XCIgKyBzdHlsZVR4dCArIFwifVwiKTtcclxuICAgICAgICAgICAgc3R5bGVJbmRleCA9IHN0eWxlU2hlZXQuY3NzUnVsZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBhbmltZS5ydW4uYXBwbHkoYW5pbWUsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdGF0ZTogJ2luJyxcclxuICAgICAgICBzdGFydGVkOiBmYWxzZSxcclxuICAgICAgICBlbmRlZDogZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlciAmJiBoYW5kbGVyKCk7XHJcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0LmRlbGV0ZVJ1bGUoc3R5bGVJbmRleCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGluQW5pbWF0aW9uLm9uKCdlbmRlZCcsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgb3V0QW5pbWF0aW9uLm9uKCdlbmRlZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcnVuOiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChzZWxmLnN0YXRlID09PSAnaW4nKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmluLmFwcGx5KHNlbGYsIFtub2RlXS5jb25jYXQoYXJncykpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdvdXQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5vdXQuYXBwbHkoc2VsZiwgW25vZGVdLmNvbmNhdChhcmdzKSk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gJ2luJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW46IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldENoYW5nZUNCLmFwcGx5KHZvaWQgMCwgW25vZGUsICdpbiddLmNvbmNhdChhcmdzKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvdXQ6IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldENoYW5nZUNCLmFwcGx5KHZvaWQgMCwgW25vZGUsICdvdXQnXS5jb25jYXQoYXJncykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxyXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5pbXBvcnQgeyBhbmltYXRlIH0gZnJvbSAnLi90b29scyc7XHJcbmltcG9ydCB7IGN1YmljT3V0IH0gZnJvbSAnLi90cmFuc2l0aW9uJztcclxuZXhwb3J0IGZ1bmN0aW9uIEZhZGVBbmltYXRpb24ob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkZWxheTogMCwgZHVyYXRpb246IDQwMCB9O1xyXG4gICAgcmV0dXJuIGFuaW1hdGUob3B0aW9ucywgZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICB2YXIgb3BhY2l0eSA9ICsoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5vcGFjaXR5IHx8IDApO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocHJvZ3Jlc3MpIHsgcmV0dXJuIFwib3BhY2l0eTogXCIgKyBwcm9ncmVzcyAqIG9wYWNpdHkgKyBcIjtcIjsgfTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBGbHlBbmltYXRpb24ob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkZWxheTogMCwgZHVyYXRpb246IDQwMCwgeDogMCwgeTogMCwgZWFzZTogY3ViaWNPdXQgfTtcclxuICAgIHJldHVybiBhbmltYXRlKG9wdGlvbnMsIGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdmFyIG9wYWNpdHksIHRyYW5zZm9ybTtcclxuICAgICAgICB2YXIgX2EgPSBfX2Fzc2lnbih7IHg6IDAsIHk6IDAgfSwgb3B0aW9ucyksIHggPSBfYS54LCB5ID0gX2EueTtcclxuICAgICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xyXG4gICAgICAgIG9wYWNpdHkgPSArKHN0eWxlLm9wYWNpdHkgfHwgMCk7XHJcbiAgICAgICAgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IChzdHlsZS50cmFuc2Zvcm0gPyBzdHlsZS50cmFuc2Zvcm0gKyBcIiBcIiA6ICcnKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHByb2dyZXNzKSB7IHJldHVybiBcIm9wYWNpdHk6IFwiICsgcHJvZ3Jlc3MgKiBvcGFjaXR5ICsgXCI7IFwiICtcclxuICAgICAgICAgICAgKFwidHJhbnNmb3JtOiBcIiArIHRyYW5zZm9ybSArIFwidHJhbnNsYXRlKFwiICsgKDEgLSBwcm9ncmVzcykgKiAoeCB8fCAwKSArIFwicHgsIFwiICsgKDEgLSBwcm9ncmVzcykgKiAoeSB8fCAwKSArIFwicHgpO1wiKTsgfTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBTbGlkZUFuaW1hdGlvbihvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRlbGF5OiAwLCBkdXJhdGlvbjogNDAwLCBlYXNlOiBjdWJpY091dCB9O1xyXG4gICAgcmV0dXJuIGFuaW1hdGUob3B0aW9ucywgZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICB2YXIgb3BhY2l0eSwgaGVpZ2h0LCBwYWRkaW5nVG9wLCBwYWRkaW5nQm90dG9tLCBtYXJnaW5Ub3AsIG1hcmdpbkJvdHRvbSwgYm9yZGVyVG9wV2lkdGgsIGJvcmRlckJvdHRvbVdpZHRoO1xyXG4gICAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XHJcbiAgICAgICAgb3BhY2l0eSA9ICsoc3R5bGUub3BhY2l0eSB8fCAwKTtcclxuICAgICAgICBoZWlnaHQgPSBwYXJzZUZsb2F0KHN0eWxlLmhlaWdodCB8fCAnMCcpO1xyXG4gICAgICAgIG1hcmdpblRvcCA9IHBhcnNlRmxvYXQoc3R5bGUubWFyZ2luVG9wIHx8ICcwJyk7XHJcbiAgICAgICAgcGFkZGluZ1RvcCA9IHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ1RvcCB8fCAnMCcpO1xyXG4gICAgICAgIG1hcmdpbkJvdHRvbSA9IHBhcnNlRmxvYXQoc3R5bGUubWFyZ2luQm90dG9tIHx8ICcwJyk7XHJcbiAgICAgICAgcGFkZGluZ0JvdHRvbSA9IHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ0JvdHRvbSB8fCAnMCcpO1xyXG4gICAgICAgIGJvcmRlclRvcFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJUb3BXaWR0aCB8fCAnMCcpO1xyXG4gICAgICAgIGJvcmRlckJvdHRvbVdpZHRoID0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJCb3R0b21XaWR0aCB8fCAnMCcpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocHJvZ3Jlc3MpIHsgcmV0dXJuIFwib3ZlcmZsb3c6IGhpZGRlbjtcIiArXHJcbiAgICAgICAgICAgIChcImhlaWdodDogXCIgKyBwcm9ncmVzcyAqIGhlaWdodCArIFwicHg7XCIpICtcclxuICAgICAgICAgICAgKFwibWFyZ2luLXRvcDogXCIgKyBwcm9ncmVzcyAqIG1hcmdpblRvcCArIFwicHg7XCIpICtcclxuICAgICAgICAgICAgKFwicGFkZGluZy10b3A6IFwiICsgcHJvZ3Jlc3MgKiBwYWRkaW5nVG9wICsgXCJweDtcIikgK1xyXG4gICAgICAgICAgICAoXCJtYXJnaW4tYm90dG9tOiBcIiArIHByb2dyZXNzICogbWFyZ2luQm90dG9tICsgXCJweDtcIikgK1xyXG4gICAgICAgICAgICAoXCJwYWRkaW5nLWJvdHRvbTogXCIgKyBwcm9ncmVzcyAqIHBhZGRpbmdCb3R0b20gKyBcInB4O1wiKSArXHJcbiAgICAgICAgICAgIChcImJvcmRlci10b3Atd2lkdGg6IFwiICsgcHJvZ3Jlc3MgKiBib3JkZXJUb3BXaWR0aCArIFwicHg7XCIpICtcclxuICAgICAgICAgICAgKFwib3BhY2l0eTogXCIgKyBNYXRoLm1pbihwcm9ncmVzcyAqIDIwLCAxKSAqIG9wYWNpdHkgKyBcIjtcIikgK1xyXG4gICAgICAgICAgICAoXCJib3JkZXItYm90dG9tLXdpZHRoOiBcIiArIHByb2dyZXNzICogYm9yZGVyQm90dG9tV2lkdGggKyBcInB4O1wiKTsgfTtcclxuICAgIH0pO1xyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgXyRlbXB0eUVsc2UsXHJcbiAgXyRDdG9yLFxyXG4gIF8kc2V0QXR0cixcclxuICBfJGVsLFxyXG4gIF8kaW5zZXJ0U3R5bGUsXHJcbiAgXyRyZW1vdmVTdHlsZSxcclxuICBfJGFkZExpc3RlbmVyLFxyXG4gIF8kcmVtb3ZlTGlzdGVuZXIsXHJcbiAgXyRkZXN0cm95Q29tcG9uZW50LFxyXG4gIF8kbm9vcCxcclxuICBfJHNldFJlZmVyZW5jZSxcclxuICBfJHNlbGVjdCxcclxuICBfJGRvY0ZyYWdtZW50LFxyXG4gIF8kYXBwZW5kLFxyXG4gIF8kcmVtb3ZlUmVmZXJlbmNlLFxyXG4gIF8kdGV4dFVwZGF0ZSxcclxuICBfJHRleHQsXHJcbiAgXyRjb25kaXRpb25hbFVwZGF0ZSxcclxuICBfJHNldEVsZW1lbnRzLFxyXG59IGZyb20gJ3RyZWJvci10b29scyc7XHJcbmltcG9ydCB7IFNsaWRlQW5pbWF0aW9uIH0gZnJvbSAndHJlYm9yLXRyYW5zaXRpb25zJztcclxuZnVuY3Rpb24gaWZDb25kaXRpb25fMShfJHN0YXRlKSB7XHJcbiAgdmFyIF8kZnJhZywgZGl2XzEsIHR4dF8xLCBfcmVmcztcclxuICBfJGZyYWcgPSBfJGRvY0ZyYWdtZW50KCk7XHJcbiAgX3JlZnMgPSBfJHN0YXRlLiRyZWZzO1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiAnaWYnLFxyXG5cclxuICAgICRjcmVhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBkaXZfMSA9IF8kZWwoKTtcclxuICAgICAgdHh0XzEgPSBfJHRleHQoJ0hlbGxvIHdvcmQhJyk7XHJcbiAgICAgIF8kc2V0UmVmZXJlbmNlKF9yZWZzLCAnYm94JywgZGl2XzEpO1xyXG4gICAgfSxcclxuXHJcbiAgICAkbW91bnQ6IGZ1bmN0aW9uKHBhcmVudCwgc2libGluZykge1xyXG4gICAgICB0aGlzLiR1bm1vdW50KCk7XHJcbiAgICAgIF8kYXBwZW5kKF8kc2VsZWN0KHBhcmVudCksIF8kZnJhZywgXyRzZWxlY3Qoc2libGluZykpO1xyXG4gICAgfSxcclxuXHJcbiAgICAkdXBkYXRlOiBfJG5vb3AsXHJcblxyXG4gICAgJHVubW91bnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBfJGFwcGVuZChkaXZfMSwgdHh0XzEpO1xyXG4gICAgICBfJGFwcGVuZChfJGZyYWcsIGRpdl8xKTtcclxuICAgIH0sXHJcblxyXG4gICAgJGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLiR1bm1vdW50KCk7XHJcbiAgICAgIF8kcmVtb3ZlUmVmZXJlbmNlKF9yZWZzLCAnYm94JywgZGl2XzEpO1xyXG4gICAgICBfJGZyYWcgPSBkaXZfMSA9IHR4dF8xID0gX3JlZnMgPSB2b2lkIDA7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBjb25kaXRpb25fMShfJHN0YXRlKSB7XHJcbiAgaWYgKF8kc3RhdGUudmlzaWJsZSlcclxuICAgIHJldHVybiBpZkNvbmRpdGlvbl8xKF8kc3RhdGUpO1xyXG4gIGVsc2VcclxuICAgIHJldHVybiBfJGVtcHR5RWxzZSgpO1xyXG59XHJcbmZ1bmN0aW9uIF8kdHBsQW5pbWF0aW9uKF8kc3RhdGUpIHtcclxuICB2YXIgXyRmcmFnLCBpbnB1dF8xLCBjaGFuZ2VFdmVudF8xLCBoYW5kbGVyQ2hhbmdlRXZlbnRfMSwgbGFiZWxfMSwgdHh0XzEsIHNldFR4dF8xLCBjb25kaXRpb25BbmNob3JfMSwgY29uZGl0aW9uQmxvY2tfMTtcclxuICBfJGZyYWcgPSBfJGRvY0ZyYWdtZW50KCk7XHJcbiAgY2hhbmdlRXZlbnRfMSA9IGZ1bmN0aW9uKF8kc3RhdGUsICRldmVudCwgJGVsKSB7XHJcbiAgICBfJHN0YXRlLm9uQ2hhbmdlKCRlbC5jaGVja2VkKTtcclxuICB9O1xyXG4gIHNldFR4dF8xID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gJ1Zpc2libGU6ICc7XHJcbiAgfTtcclxuICAnKyhfJHN0YXRlLnZpc2libGUpKyc7XHJcbiAgJyc7XHJcbiAgY29uZGl0aW9uQW5jaG9yXzEgPSBfJHRleHQoKTtcclxuICByZXR1cm4ge1xyXG4gICAgJGNyZWF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlucHV0XzEgPSBfJGVsKCdpbnB1dCcpO1xyXG4gICAgICBsYWJlbF8xID0gXyRlbCgnbGFiZWwnKTtcclxuICAgICAgdHh0XzEgPSBfJHRleHQoKTtcclxuICAgICAgdHh0XzEuZGF0YSA9IHNldFR4dF8xKF8kc3RhdGUpO1xyXG4gICAgICBjb25kaXRpb25CbG9ja18xID0gY29uZGl0aW9uXzEoXyRzdGF0ZSk7XHJcbiAgICAgIGNvbmRpdGlvbkJsb2NrXzEuJGNyZWF0ZSgpO1xyXG4gICAgICBfJHNldEF0dHIoaW5wdXRfMSwgWydpZCcsICd2aXNpYmxlJ10pO1xyXG4gICAgICBfJHNldEF0dHIoaW5wdXRfMSwgWyd0eXBlJywgJ2NoZWNrYm94J10pO1xyXG4gICAgICBfJGFkZExpc3RlbmVyKGlucHV0XzEsICdjaGFuZ2UnLCBoYW5kbGVyQ2hhbmdlRXZlbnRfMSA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgY2hhbmdlRXZlbnRfMShfJHN0YXRlLCBldmVudCwgaW5wdXRfMSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBfJHNldEF0dHIobGFiZWxfMSwgWydmb3InLCAndmlzaWJsZSddKTtcclxuICAgIH0sXHJcblxyXG4gICAgJG1vdW50OiBmdW5jdGlvbihwYXJlbnQsIHNpYmxpbmcpIHtcclxuICAgICAgdGhpcy4kdW5tb3VudCgpO1xyXG4gICAgICBfJGluc2VydFN0eWxlKFxyXG4gICAgICAgICdzY29wZV8yZDgyNjc0MCcsXHJcbiAgICAgICAgJ2RpdiB7d2lkdGg6MTI1cHg7cGFkZGluZzo0NXB4IDA7Y29sb3I6d2hpdGU7dGV4dC1hbGlnbjpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjpibGFjazt9J1xyXG4gICAgICApO1xyXG4gICAgICBfJGFwcGVuZChfJHNlbGVjdChwYXJlbnQpLCBfJGZyYWcsIF8kc2VsZWN0KHNpYmxpbmcpKTtcclxuICAgICAgXyRzZXRFbGVtZW50cyh0aGlzLCBwYXJlbnQsIHNpYmxpbmcpO1xyXG4gICAgfSxcclxuXHJcbiAgICAkdXBkYXRlOiBmdW5jdGlvbihfJHN0YXRlKSB7XHJcbiAgICAgIF8kdGV4dFVwZGF0ZSh0eHRfMSwgc2V0VHh0XzEoXyRzdGF0ZSkpO1xyXG4gICAgICBjb25kaXRpb25CbG9ja18xID0gXyRjb25kaXRpb25hbFVwZGF0ZShjb25kaXRpb25CbG9ja18xLCBjb25kaXRpb25fMSwgdW5kZWZpbmVkLCBjb25kaXRpb25BbmNob3JfMSwgXyRzdGF0ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgICR1bm1vdW50OiBmdW5jdGlvbigpIHtcclxuICAgICAgXyRhcHBlbmQoXyRmcmFnLCBpbnB1dF8xKTtcclxuICAgICAgXyRhcHBlbmQobGFiZWxfMSwgdHh0XzEpO1xyXG4gICAgICBfJGFwcGVuZChfJGZyYWcsIGxhYmVsXzEpO1xyXG4gICAgICBfJGFwcGVuZChfJGZyYWcsIGNvbmRpdGlvbkFuY2hvcl8xKTtcclxuICAgICAgY29uZGl0aW9uQmxvY2tfMS4kbW91bnQoXyRmcmFnLCBjb25kaXRpb25BbmNob3JfMSk7XHJcbiAgICB9LFxyXG5cclxuICAgICRkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgXyRkZXN0cm95Q29tcG9uZW50KHRoaXMpO1xyXG4gICAgICBfJHJlbW92ZVN0eWxlKCdzY29wZV8yZDgyNjc0MCcpO1xyXG4gICAgICBfJHJlbW92ZUxpc3RlbmVyKGlucHV0XzEsICdjaGFuZ2UnLCBoYW5kbGVyQ2hhbmdlRXZlbnRfMSk7XHJcbiAgICAgIGNvbmRpdGlvbkJsb2NrXzEuJGRlc3Ryb3koKTtcclxuICAgICAgZGVsZXRlIF8kc3RhdGUuJHJvb3Q7XHJcbiAgICAgIF8kZnJhZyA9IGlucHV0XzEgPSBjaGFuZ2VFdmVudF8xID0gaGFuZGxlckNoYW5nZUV2ZW50XzEgPSBsYWJlbF8xID0gdHh0XzEgPSBzZXRUeHRfMSA9IGNvbmRpdGlvbkFuY2hvcl8xID0gY29uZGl0aW9uQmxvY2tfMSA9IHZvaWQgMDtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbnZhciBhbmltYXRpb24gPSBTbGlkZUFuaW1hdGlvbih7XHJcbiAgeTogMzAwLFxyXG4gIGR1cmF0aW9uOiAxMjAwXHJcbn0pO1xyXG52YXIgQW5pbWF0aW9uID0gXyRDdG9yKCdBbmltYXRpb24nLCBfJHRwbEFuaW1hdGlvbiwge1xyXG4gIG1vZGVsOiB7XHJcbiAgICB2aXNpYmxlOiBmYWxzZSxcclxuXHJcbiAgICBvbkNoYW5nZTogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgdmFyIHJlZnMgPSB0aGlzLiRyZWZzO1xyXG4gICAgICBhbmltYXRpb24uZW5kZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIXZhbHVlICYmIF90aGlzLiR1cGRhdGUoKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuJHNldCgndmlzaWJsZScsIHZhbHVlKTtcclxuICAgICAgICBhbmltYXRpb24uaW4ocmVmcy5ib3gpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHZhbHVlO1xyXG4gICAgICAgIGFuaW1hdGlvbi5vdXQocmVmcy5ib3gpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59KTtcclxuZXhwb3J0IGRlZmF1bHQgQW5pbWF0aW9uO1xyXG4iLCJpbXBvcnQgQW5pbWF0aW9uIGZyb20gJy4vY29tcG9uZW50cy9hbmltYXRpb24uaHRtbCc7XHJcblxyXG5jb25zdCBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKCk7XHJcblxyXG5hbmltYXRpb24uJG1vdW50KCdtYWluJyk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./main.ts\n");

/***/ })

/******/ });