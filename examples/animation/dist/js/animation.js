/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../../trebor-transitions/node_modules/hash-sum/hash-sum.js":
/*!****************************************************************************!*\
  !*** h:/trebor-repos/trebor-transitions/node_modules/hash-sum/hash-sum.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction pad (hash, len) {\n  while (hash.length < len) {\n    hash = '0' + hash;\n  }\n  return hash;\n}\n\nfunction fold (hash, text) {\n  var i;\n  var chr;\n  var len;\n  if (text.length === 0) {\n    return hash;\n  }\n  for (i = 0, len = text.length; i < len; i++) {\n    chr = text.charCodeAt(i);\n    hash = ((hash << 5) - hash) + chr;\n    hash |= 0;\n  }\n  return hash < 0 ? hash * -2 : hash;\n}\n\nfunction foldObject (hash, o, seen) {\n  return Object.keys(o).sort().reduce(foldKey, hash);\n  function foldKey (hash, key) {\n    return foldValue(hash, o[key], key, seen);\n  }\n}\n\nfunction foldValue (input, value, key, seen) {\n  var hash = fold(fold(fold(input, key), toString(value)), typeof value);\n  if (value === null) {\n    return fold(hash, 'null');\n  }\n  if (value === undefined) {\n    return fold(hash, 'undefined');\n  }\n  if (typeof value === 'object') {\n    if (seen.indexOf(value) !== -1) {\n      return fold(hash, '[Circular]' + key);\n    }\n    seen.push(value);\n    return foldObject(hash, value, seen);\n  }\n  return fold(hash, value.toString());\n}\n\nfunction toString (o) {\n  return Object.prototype.toString.call(o);\n}\n\nfunction sum (o) {\n  return pad(foldValue(0, o, '', []).toString(16), 8);\n}\n\nmodule.exports = sum;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vaDovdHJlYm9yLXJlcG9zL3RyZWJvci10cmFuc2l0aW9ucy9ub2RlX21vZHVsZXMvaGFzaC1zdW0vaGFzaC1zdW0uanM/M2Y5YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuLi8uLi8uLi8uLi90cmVib3ItdHJhbnNpdGlvbnMvbm9kZV9tb2R1bGVzL2hhc2gtc3VtL2hhc2gtc3VtLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBwYWQgKGhhc2gsIGxlbikge1xuICB3aGlsZSAoaGFzaC5sZW5ndGggPCBsZW4pIHtcbiAgICBoYXNoID0gJzAnICsgaGFzaDtcbiAgfVxuICByZXR1cm4gaGFzaDtcbn1cblxuZnVuY3Rpb24gZm9sZCAoaGFzaCwgdGV4dCkge1xuICB2YXIgaTtcbiAgdmFyIGNocjtcbiAgdmFyIGxlbjtcbiAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gdGV4dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNociA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBjaHI7XG4gICAgaGFzaCB8PSAwO1xuICB9XG4gIHJldHVybiBoYXNoIDwgMCA/IGhhc2ggKiAtMiA6IGhhc2g7XG59XG5cbmZ1bmN0aW9uIGZvbGRPYmplY3QgKGhhc2gsIG8sIHNlZW4pIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG8pLnNvcnQoKS5yZWR1Y2UoZm9sZEtleSwgaGFzaCk7XG4gIGZ1bmN0aW9uIGZvbGRLZXkgKGhhc2gsIGtleSkge1xuICAgIHJldHVybiBmb2xkVmFsdWUoaGFzaCwgb1trZXldLCBrZXksIHNlZW4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvbGRWYWx1ZSAoaW5wdXQsIHZhbHVlLCBrZXksIHNlZW4pIHtcbiAgdmFyIGhhc2ggPSBmb2xkKGZvbGQoZm9sZChpbnB1dCwga2V5KSwgdG9TdHJpbmcodmFsdWUpKSwgdHlwZW9mIHZhbHVlKTtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZvbGQoaGFzaCwgJ251bGwnKTtcbiAgfVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmb2xkKGhhc2gsICd1bmRlZmluZWQnKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChzZWVuLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGZvbGQoaGFzaCwgJ1tDaXJjdWxhcl0nICsga2V5KTtcbiAgICB9XG4gICAgc2Vlbi5wdXNoKHZhbHVlKTtcbiAgICByZXR1cm4gZm9sZE9iamVjdChoYXNoLCB2YWx1ZSwgc2Vlbik7XG4gIH1cbiAgcmV0dXJuIGZvbGQoaGFzaCwgdmFsdWUudG9TdHJpbmcoKSk7XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nIChvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cbmZ1bmN0aW9uIHN1bSAobykge1xuICByZXR1cm4gcGFkKGZvbGRWYWx1ZSgwLCBvLCAnJywgW10pLnRvU3RyaW5nKDE2KSwgOCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3VtO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../../trebor-transitions/node_modules/hash-sum/hash-sum.js\n");

/***/ }),

/***/ "./main.ts":
/*!*****************************!*\
  !*** ./main.ts + 5 modules ***!
  \*****************************/
/*! no exports provided */
/*! ModuleConcatenation bailout: Cannot concat with h:/trebor-repos/trebor-transitions/node_modules/hash-sum/hash-sum.js (<- Module is not an ECMAScript module) */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("\n// CONCATENATED MODULE: h:/trebor-repos/trebor/tools/index.js\nvar PROP_MAP = { p: '__TP__', v: 'value', _: '_value', s: '_subscribers', e: '_events', w: '_watchers', h: 'prototype' };\r\nvar PROPS = ['$slots', '$refs', '$filters', '$directives', '_events', '_watchers'];\r\nvar TPS = window[PROP_MAP.p] || (window[PROP_MAP.p] = []);\r\nvar _$assign = Object['assign'] || function (t) {\r\n    for (var s = void 0, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s)\r\n            if (_$hasProp(s, p))\r\n                t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nfunction _$CompCtr(attrs, template, options, parent) {\r\n    var self = this;\r\n    var _$set = function (prop, value) { _$def(self, prop, { value: value, writable: true }); };\r\n    if (!attrs)\r\n        attrs = {};\r\n    _$e(PROPS, function (prop) { _$def(self, prop, { value: {} }); });\r\n    _$set('$parent', parent || null);\r\n    _$set('$children', []);\r\n    _$set(PROP_MAP.s, {});\r\n    _$set('$options', options);\r\n    var opts = self.$options;\r\n    if (!opts.attrs)\r\n        opts.attrs = {};\r\n    if (!opts.children)\r\n        opts.children = {};\r\n    _$e(TPS, function (plugin) { plugin.fn.call(self, _$CompCtr, plugin.options); });\r\n    if (opts.filters)\r\n        _$assign(self.$filters, opts.filters);\r\n    if (opts.directives)\r\n        _$e(opts.directives, function (drt, k) { self.$directives[k] = _$drt(drt); });\r\n    _$e(opts.attrs, function (attrOps, key) {\r\n        _$def(self, (_$isType(key, 'number') ? attrOps : key), {\r\n            get: function () {\r\n                if (_$isStr(attrOps)) {\r\n                    var value = attrs[attrOps];\r\n                    return _$isFunction(value) ? value() : value;\r\n                }\r\n                else {\r\n                    if (!_$hasProp(attrs, key) && attrOps.required) {\r\n                        return console.error(\"Attribute '\" + key + \"' is required.\");\r\n                    }\r\n                    else {\r\n                        var value = _$isFunction(attrs[key]) ? attrs[key]() : attrs[key];\r\n                        if (value === void 0 && _$hasProp(attrOps, 'default')) {\r\n                            var def = attrOps.default;\r\n                            value = _$isFunction(def) ? def() : def;\r\n                        }\r\n                        var typ = attrOps.type;\r\n                        if (typ && !_$isType(value, typ) && attrOps.required) {\r\n                            return console.error(\"Attribute '\" + key + \"' must be type '\" + typ + \"'.\");\r\n                        }\r\n                        value = _$toType(value, value === void 0 ? 'undefined' : typ, self, key);\r\n                        if (value !== void 0 && _$hasProp(attrOps, 'validator')) {\r\n                            var validator = attrOps.validator;\r\n                            if (_$isFunction(validator) && !validator(value)) {\r\n                                return console.error(\"Assigment '\" + key + \"'='\" + JSON.stringify(value) + \"' invalid.\");\r\n                            }\r\n                        }\r\n                        return value;\r\n                    }\r\n                }\r\n            },\r\n            set: function () {\r\n                console.error(\"'\" + key + \"' is read only.\");\r\n            },\r\n            enumerable: true, configurable: true\r\n        });\r\n    });\r\n    var data = opts.model || {};\r\n    var _loop_1 = function (key) {\r\n        if (_$hasProp(data, key)) {\r\n            var desc = Object.getOwnPropertyDescriptor(data, key);\r\n            if (desc.value && _$isArray(desc.value)) {\r\n                desc.value = new _$List(desc.value, self, key);\r\n            }\r\n            else {\r\n                if (desc.get) {\r\n                    var getter_1 = desc.get;\r\n                    desc.get = function () {\r\n                        var value = getter_1.call(self);\r\n                        if (_$isArray(value))\r\n                            value = new _$List(value, self, key);\r\n                        return value;\r\n                    };\r\n                }\r\n                if (desc.set) {\r\n                    var setter_1 = desc.set;\r\n                    desc.set = function (v) {\r\n                        if (_$isArray(v))\r\n                            v = new _$List(v, self, key);\r\n                        setter_1.call(self, v);\r\n                    };\r\n                }\r\n            }\r\n            _$def(self, key, desc);\r\n        }\r\n    };\r\n    for (var key in data) {\r\n        _loop_1(key);\r\n    }\r\n    var tpl = template(self);\r\n    _$e(tpl, function (value, key) {\r\n        _$def(self, key, {\r\n            value: (function (key) {\r\n                var hook = key[1].toUpperCase() + key.slice(2);\r\n                var bhook = opts[\"before\" + hook];\r\n                var ahook = opts[\"after\" + hook];\r\n                return function () {\r\n                    bhook && bhook.call(this);\r\n                    key.slice(1) === 'update' ? value.call(this, this) : value.apply(this, arguments);\r\n                    ahook && ahook.call(this);\r\n                };\r\n            })(key)\r\n        });\r\n    });\r\n    _$def(self, '$data', {\r\n        get: function () {\r\n            return _$toPlainObj(this);\r\n        }\r\n    });\r\n}\r\nfunction _$isValueAttr(attr) {\r\n    return attr === 'value';\r\n}\r\nfunction _$subs(dep, listener) {\r\n    if (!this[PROP_MAP.s][dep]) {\r\n        this[PROP_MAP.s][dep] = [];\r\n    }\r\n    return this[PROP_MAP.s][dep].push(listener.bind(this)) - 1;\r\n}\r\nfunction _$def(obj, key, desc) {\r\n    Object.defineProperty(obj, key, desc);\r\n}\r\n_$assign(_$CompCtr[PROP_MAP.h], {\r\n    $get: function (path) {\r\n        return _$accesor(this, path);\r\n    },\r\n    $set: function (path, value) {\r\n        _$accesor(this, path, value);\r\n    },\r\n    $on: function (event, handler) {\r\n        var _this = this;\r\n        if (!this[PROP_MAP.e][event]) {\r\n            this[PROP_MAP.e][event] = [];\r\n        }\r\n        var i = this[PROP_MAP.e][event].push(handler);\r\n        return {\r\n            $off: function () {\r\n                _this[PROP_MAP.e][event].splice(i - 1, 1);\r\n            }\r\n        };\r\n    },\r\n    $once: function (event, handler) {\r\n        var e = this.$on(event, function (args) {\r\n            handler(args);\r\n            e.$off();\r\n        });\r\n    },\r\n    $fire: function (event, data) {\r\n        if (this[PROP_MAP.e][event]) {\r\n            _$e(this[PROP_MAP.e][event], function (handler) { handler(data); });\r\n        }\r\n    },\r\n    $notify: function (key) {\r\n        if (this[PROP_MAP.s][key]) {\r\n            _$e(this[PROP_MAP.s][key], function (suscriber) { suscriber(); });\r\n        }\r\n    },\r\n    $observe: function (deps, listener) {\r\n        var _this = this;\r\n        var subs = [];\r\n        if (_$isArray(deps)) {\r\n            _$e(deps, function (dep) {\r\n                subs.push({ sub: dep, i: _$subs.call(_this, dep, listener) });\r\n            });\r\n        }\r\n        else {\r\n            subs.push({ sub: deps, i: _$subs.call(this, deps, listener) });\r\n        }\r\n        return {\r\n            $unobserve: function () {\r\n                _$e(subs, function (sub) {\r\n                    _this[PROP_MAP.s][sub.sub].splice(sub.i, 1);\r\n                });\r\n            }\r\n        };\r\n    },\r\n    $watch: function (key, watcher) {\r\n        var _this = this;\r\n        if (!this[PROP_MAP.w][key]) {\r\n            this[PROP_MAP.w][key] = [];\r\n        }\r\n        var i = this[PROP_MAP.w][key].push(watcher.bind(this));\r\n        return {\r\n            $unwatch: function () {\r\n                _this[PROP_MAP.w][key].splice(i - 1, 1);\r\n            }\r\n        };\r\n    }\r\n});\r\nvar array = Array[PROP_MAP.h];\r\nfunction _$toArgs(args, start) {\r\n    if (start === void 0) { start = 0; }\r\n    return array.slice.call(args, start);\r\n}\r\nfunction _$arrayValues(list, value, root, key) {\r\n    array.push.apply(list, value.map(function (v, i) {\r\n        if (list.length !== 0)\r\n            i += list.length;\r\n        return !(_$isType(v, _$List)) && _$isArray(v) ? new _$List(v, root, key + \".\" + i) : v;\r\n    }));\r\n}\r\nfunction _$List(value, root, key) {\r\n    var self = this;\r\n    Array.apply(self, [value.length]);\r\n    var desc = { writable: false, configurable: false, enumerable: false };\r\n    _$def(self, '_key', _$assign({ value: key }, desc));\r\n    _$def(self, '_root', _$assign({ value: root }, desc));\r\n    _$arrayValues(self, value, root, key);\r\n    desc.writable = true;\r\n    _$def(self, 'length', _$assign({ value: self.length }, desc));\r\n}\r\n_$extends(_$List, Array);\r\n['pop', 'push', 'reverse', 'shift', 'sort', 'fill', 'unshift', 'splice'].forEach(function (method) {\r\n    _$List[PROP_MAP.h][method] = function () {\r\n        var self = this;\r\n        var old = self.slice();\r\n        var result;\r\n        if (method === 'push') {\r\n            _$arrayValues(self, _$toArgs(arguments), self._root, self._key);\r\n            result = self.length;\r\n        }\r\n        else {\r\n            result = array[method].apply(self, arguments);\r\n        }\r\n        _$dispatch(self._root, self._key, old, self.slice());\r\n        return result;\r\n    };\r\n});\r\n_$List[PROP_MAP.h].pull = function (index) {\r\n    var self = this;\r\n    var items = _$toArgs(arguments, 1);\r\n    var length = self.length;\r\n    if (index > length) {\r\n        length = index + 1;\r\n        var pull = new Array(index - self.length);\r\n        pull.push.apply(pull, items);\r\n        for (var i = 0; i < length; i++) {\r\n            if (i === index) {\r\n                self.push.apply(self, pull);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        self.splice.apply(self, [index, 1].concat(items));\r\n    }\r\n};\r\nfunction _$dispatch(root, key, oldVal, value) {\r\n    root.$notify(key);\r\n    if (root[PROP_MAP.w][key]) {\r\n        _$e(root[PROP_MAP.w][key], function (watcher) { watcher(oldVal, value); });\r\n    }\r\n    root.$update();\r\n}\r\nfunction _$extends(ctor, exts) {\r\n    ctor['plugin'] = function (fn, options) {\r\n        TPS.push({ options: options, fn: fn });\r\n    };\r\n    ctor[PROP_MAP.h] = Object.create(exts[PROP_MAP.h]);\r\n    ctor[PROP_MAP.h].constructor = ctor;\r\n}\r\nfunction _$isType(value, type) {\r\n    return _$type(type) === 'string' ? type.split('|').some(function (t) { return t.trim() === _$type(value); }) : value instanceof type;\r\n}\r\nfunction _$apply(callee, args, globs, thisArg) {\r\n    if (thisArg === void 0) { thisArg = null; }\r\n    return callee.apply(thisArg, args.concat(globs));\r\n}\r\nfunction _$isObject(obj) {\r\n    return _$isType(obj, 'object');\r\n}\r\nfunction _$isArray(obj) {\r\n    return Array.isArray ? Array.isArray(obj) : _$isType(obj, 'array');\r\n}\r\nfunction _$isFunction(obj) {\r\n    return _$isType(obj, 'function');\r\n}\r\nfunction _$isStr(obj) {\r\n    return _$isType(obj, 'string');\r\n}\r\nfunction _$toType(value, type, root, key) {\r\n    switch (type) {\r\n        case 'date':\r\n            return new Date(value);\r\n        case 'string':\r\n            return _$toStr(value);\r\n        case 'number':\r\n            return +value;\r\n        case 'boolean':\r\n            return _$isStr(value) && !value ? true : !!value;\r\n        case 'array':\r\n            return _$isType(value, _$List) ? value : new _$List(value, root, key);\r\n        default:\r\n            return value;\r\n    }\r\n}\r\nfunction _$type(obj) {\r\n    return / (\\w+)/.exec(({}).toString.call(obj))[1].toLowerCase();\r\n}\r\nfunction _$hasProp(obj, prop) {\r\n    return obj.hasOwnProperty(prop);\r\n}\r\nfunction _$drt(dd) {\r\n    var hasProp = function (prop, instance, options, element) { return _$isObject(dd) && dd[prop] && dd[prop](instance, options, element); };\r\n    return {\r\n        $init: function (instance, options, element) {\r\n            hasProp('$init', instance, options, element);\r\n        },\r\n        $inserted: function (instance, options, element) {\r\n            hasProp('$inserted', instance, options, element);\r\n        },\r\n        $update: function (instance, options, element) {\r\n            if (_$isFunction(dd)) {\r\n                dd(instance, options, element);\r\n            }\r\n            else {\r\n                hasProp('$update', instance, options, element);\r\n            }\r\n        },\r\n        $destroy: function (instance, options, element) {\r\n            hasProp('$destroy', instance, options, element);\r\n        }\r\n    };\r\n}\r\nfunction _$noop() { }\r\nfunction _$add(inst, Child, attrs) {\r\n    var child = null;\r\n    if (Child) {\r\n        child = new Child(attrs, inst);\r\n        inst.$children.push(child);\r\n    }\r\n    return child;\r\n}\r\nfunction _$remove(inst, child) {\r\n    var index = inst.$children.indexOf(child);\r\n    index >= 0 && inst.$children.splice(index, 1);\r\n}\r\nfunction _$toStr(obj) {\r\n    var str = _$type(obj);\r\n    return !/null|undefined/.test(str) ? obj.toString() : str;\r\n}\r\nfunction _$toPlainObj(obj) {\r\n    var data = {};\r\n    _$e(_$isObject(obj) ? obj : {}, function (_v, k) {\r\n        if (k[0] !== '$' && !_$isFunction(obj[k])) {\r\n            if (_$isType(obj[k], _$List)) {\r\n                data[k] = obj[k].map(_$toPlainObj);\r\n            }\r\n            else if (_$isObject(obj[k])) {\r\n                data[k] = _$toPlainObj(obj[k]);\r\n            }\r\n            else {\r\n                data[k] = obj[k];\r\n            }\r\n        }\r\n    });\r\n    return _$isObject(obj) ? data : obj;\r\n}\r\nfunction _$setRef(refs, prop, node) {\r\n    if (!_$hasProp(refs, prop)) {\r\n        var value_1 = [];\r\n        _$def(refs, prop, {\r\n            get: function () { return value_1.length <= 1 ? value_1[0] : value_1; },\r\n            set: function (val) { val && !~value_1.indexOf(val) && value_1.push(val); },\r\n            enumerable: true, configurable: true\r\n        });\r\n    }\r\n    refs[prop] = node;\r\n}\r\nfunction _$accesor(object, path, value) {\r\n    return path.split('.').reduce(function (obj, key, i, arr) {\r\n        if (_$isType(value, 'undefined')) {\r\n            if (obj == null) {\r\n                arr.splice(0, arr.length);\r\n                return i > 0 && obj === null ? obj : undefined;\r\n            }\r\n        }\r\n        else {\r\n            if (i === arr.length - 1) {\r\n                if (_$isType(obj, _$List) && _$toStr(+key) === key) {\r\n                    obj.pull(+key, value);\r\n                }\r\n                else {\r\n                    var oldVal = obj[key];\r\n                    obj[key] = !_$isType(value, _$List) && _$isArray(value) ? new _$List(value, object, key) : value;\r\n                    _$dispatch(object, path, oldVal, obj[key]);\r\n                }\r\n            }\r\n            else if (!_$isObject(obj[key])) {\r\n                obj[key] = {};\r\n            }\r\n        }\r\n        return obj ? obj[key] : null;\r\n    }, object);\r\n}\r\nfunction _$emptyElse() {\r\n    return { type: 'empty-else', $create: _$noop, $mount: _$noop, $update: _$noop, $destroy: _$noop };\r\n}\r\nfunction _$isKey(event, key) {\r\n    return event.key.toLowerCase() === key || !!event[key + \"Key\"];\r\n}\r\nfunction _$bindGroup(input, selection) {\r\n    var _value = _$gv(input);\r\n    var _$index = selection.indexOf(_value);\r\n    input.checked && !~_$index ? selection.push(_value) : selection.splice(_$index, 1);\r\n}\r\nfunction _$bindMultiSelect(select, selections) {\r\n    if (!selections.length)\r\n        return;\r\n    var options = select.options;\r\n    for (var i = 0; i < options.length; i++) {\r\n        options[i].selected = !!~selections.indexOf(_$gv(options[i]));\r\n    }\r\n}\r\nfunction _$updateMultiSelect(select, obj, prop) {\r\n    var items = [];\r\n    var selection = obj[prop];\r\n    var selectedOptions = select.selectedOptions;\r\n    for (var i = 0; i < selectedOptions.length; i++) {\r\n        items.push(_$gv(selectedOptions[i]));\r\n    }\r\n    obj[prop] = new _$List(items, selection['_root'], selection['_key']);\r\n    obj.$update();\r\n}\r\nfunction _$(selector, parent) {\r\n    return _$isStr(selector) ? (parent || document).querySelector(selector) : selector;\r\n}\r\nfunction _$d() {\r\n    return document.createDocumentFragment();\r\n}\r\nfunction _$a(parent, child, sibling) {\r\n    if (_$isType(sibling, 'boolean') && sibling)\r\n        parent.parentElement.replaceChild(child, parent);\r\n    else if (!sibling)\r\n        parent.appendChild(child);\r\n    else\r\n        parent.insertBefore(child, sibling);\r\n}\r\nfunction _$as(source, dest) {\r\n    var childNodes = source.childNodes, attributes = source.attributes;\r\n    for (var i = 0; i < childNodes.length; i++) {\r\n        _$a(dest, childNodes[i]);\r\n    }\r\n    for (var i = 0; i < attributes.length; i++) {\r\n        var attr = attributes[i];\r\n        dest.setAttributeNS(source.namespaceURI, attr.name, attr.value);\r\n    }\r\n    source.parentElement.replaceChild(dest, source);\r\n    return dest;\r\n}\r\nfunction _$r(el, parent) {\r\n    var root = parent || el.parentElement;\r\n    if (root)\r\n        root.removeChild(el);\r\n}\r\nfunction _$ce(tagName) {\r\n    return document.createElement(tagName || 'div');\r\n}\r\nfunction _$cse(tagName) {\r\n    return document.createElementNS('http://www.w3.org/2000/svg', tagName || 'svg');\r\n}\r\nfunction _$ct(content) {\r\n    return document.createTextNode(content || '');\r\n}\r\nfunction _$cm(content) {\r\n    return document.createComment(content || '');\r\n}\r\nfunction _$sa(el, attrAndValue) {\r\n    var attr = attrAndValue[0], value = attrAndValue[1];\r\n    el.setAttribute(attr, _$toStr(value));\r\n    if (_$isValueAttr(attr) && !_$isStr(value))\r\n        el[PROP_MAP._] = value;\r\n}\r\nfunction _$ga(el, attr) {\r\n    return _$isValueAttr(attr) ? _$gv(el) : el.getAttribute(attr);\r\n}\r\nfunction _$gv(el) {\r\n    return _$hasProp(el, PROP_MAP._) ? el[PROP_MAP._] : el[PROP_MAP.v];\r\n}\r\nfunction _$al(el, event, handler) {\r\n    el.addEventListener(event, handler, false);\r\n}\r\nfunction _$ul(el, event, oldHandler, newHandler) {\r\n    _$rl(el, event, oldHandler);\r\n    _$al(el, event, oldHandler = newHandler);\r\n    return oldHandler;\r\n}\r\nfunction _$rl(el, event, handler) {\r\n    el.removeEventListener(event, handler, false);\r\n}\r\nfunction _$bc(value) {\r\n    var classes = '';\r\n    if (_$isStr(value)) {\r\n        classes += \" \" + value;\r\n    }\r\n    else if (_$isArray(value)) {\r\n        classes = value.map(_$bc).join(' ');\r\n    }\r\n    else if (_$isObject(value)) {\r\n        for (var key in value)\r\n            if (_$hasProp(value, key) && value[key])\r\n                classes += \" \" + key;\r\n    }\r\n    return classes.trim();\r\n}\r\nfunction _$bs(value) {\r\n    var el = _$ce();\r\n    if (_$isObject(value)) {\r\n        var style_1 = el.style;\r\n        _$e(value, function (val, prop) {\r\n            if (val !== style_1[prop])\r\n                style_1[prop] = val;\r\n        });\r\n        return style_1.cssText;\r\n    }\r\n    else if (_$isStr(value)) {\r\n        return value;\r\n    }\r\n    else {\r\n        return '';\r\n    }\r\n}\r\nfunction _$cu(block, condition, parent, anchor, inst) {\r\n    var globs = _$toArgs(arguments, 5);\r\n    if (block && block.type === _$apply(condition, [inst], globs).type) {\r\n        _$apply(block.$update, [inst], globs, block);\r\n    }\r\n    else {\r\n        block && block.$destroy();\r\n        block = _$apply(condition, [inst], globs);\r\n        block.$create();\r\n        block.$mount(parent || inst.$parentEl, anchor);\r\n    }\r\n    return block;\r\n}\r\nfunction _$bba(el, attrAndValue) {\r\n    var attr = attrAndValue[0], value = attrAndValue[1];\r\n    el[attr] = value == null || value === false ? (el.removeAttribute(attr), false) : (_$sa(el, [attr, '']), true);\r\n}\r\nfunction _$bu(el, binding) {\r\n    var attr = binding[0], value = binding[1];\r\n    var _value = _$toStr(value);\r\n    if (_$isValueAttr(attr)) {\r\n        if (el[attr] !== _value)\r\n            el[attr] = _value;\r\n        el[PROP_MAP._] = value;\r\n    }\r\n    else if (_$ga(el, attr) !== _value) {\r\n        _$sa(el, [attr, _value]);\r\n    }\r\n}\r\nfunction _$tu(text, value) {\r\n    if (text.data !== (value = _$toStr(value)))\r\n        text.data = value;\r\n}\r\nfunction _$nu(node, tag) {\r\n    return tag.toUpperCase() !== node.tagName ? _$as(node, _$ce(tag)) : node;\r\n}\r\nfunction _$rr(refs, prop, node) {\r\n    var nodes = refs[prop];\r\n    _$isArray(nodes) ? refs[prop].splice(nodes.indexOf(node), 1) : (delete refs[prop]);\r\n}\r\nfunction _$hu(node, value) {\r\n    if (node.innerHTML !== (value = _$toStr(value)))\r\n        node.innerHTML = value;\r\n}\r\nfunction _$pu(parent, Ctor, inst, value, attrs, el, sibling) {\r\n    if (value === Ctor) {\r\n        inst && inst.$update();\r\n    }\r\n    else {\r\n        Ctor = value;\r\n        if (inst) {\r\n            inst.$destroy();\r\n            _$remove(parent, inst);\r\n        }\r\n        if (inst) {\r\n            inst = _$add(parent, Ctor, attrs);\r\n            inst.$create();\r\n            inst.$mount(el, sibling);\r\n        }\r\n    }\r\n    return [inst, Ctor];\r\n}\r\nfunction _$f(root, obj, loop) {\r\n    var items = {}, loopParent, loopSibling;\r\n    var globs = _$toArgs(arguments, 3);\r\n    _$e(obj, function (item, i, index) { items[i] = _$apply(loop, [root, item, i, index], globs); });\r\n    return {\r\n        $create: function () {\r\n            _$e(items, function (item) { item.$create(); });\r\n        },\r\n        $mount: function (parent, sibling) {\r\n            loopParent = _$(parent);\r\n            loopSibling = _$(sibling);\r\n            _$e(items, function (item) { item.$mount(loopParent, loopSibling); });\r\n        },\r\n        $update: function (root, obj) {\r\n            var globs = _$toArgs(arguments, 2);\r\n            _$e(items, function (item, i, index) {\r\n                if (obj[i]) {\r\n                    _$apply(item.$update, [root, obj[i], i, index], globs, item);\r\n                }\r\n                else {\r\n                    item.$destroy();\r\n                    delete items[i];\r\n                }\r\n            });\r\n            _$e(obj, function (item, i, index) {\r\n                if (!items[i]) {\r\n                    items[i] = _$apply(loop, [root, item, i, index], globs);\r\n                    items[i].$create();\r\n                    items[i].$mount(loopParent, loopSibling);\r\n                }\r\n            });\r\n        },\r\n        $destroy: function () {\r\n            _$e(items, function (item) { item.$destroy(); });\r\n        }\r\n    };\r\n}\r\nfunction _$e(obj, cb) {\r\n    var i = 0;\r\n    for (var key in obj) {\r\n        if (_$hasProp(obj, key)) {\r\n            cb(obj[key], (isNaN(+key) ? key : +key), i++);\r\n        }\r\n    }\r\n}\r\nfunction _$is(id, css) {\r\n    var isNew = false;\r\n    var style = _$(\"#\" + id, document.head);\r\n    if (!style) {\r\n        isNew = true;\r\n        style = _$ce('style');\r\n        style.id = id;\r\n        _$sa(style, ['refs', 1]);\r\n    }\r\n    if (style.textContent !== css) {\r\n        style.textContent = css;\r\n    }\r\n    if (isNew) {\r\n        _$a(document.head, style);\r\n    }\r\n    else {\r\n        var count = +_$ga(style, 'refs');\r\n        _$sa(style, ['refs', ++count]);\r\n    }\r\n}\r\nfunction _$ds(id) {\r\n    var style = _$(\"#\" + id, document.head);\r\n    if (style) {\r\n        var count = +_$ga(style, 'refs');\r\n        if (--count === 0) {\r\n            _$r(style, document.head);\r\n        }\r\n        else {\r\n            _$sa(style, ['refs', count]);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=index.js.map\n// EXTERNAL MODULE: h:/trebor-repos/trebor-transitions/node_modules/hash-sum/hash-sum.js\nvar hash_sum = __webpack_require__(\"../../../../trebor-transitions/node_modules/hash-sum/hash-sum.js\");\nvar hash_sum_default = /*#__PURE__*/__webpack_require__.n(hash_sum);\n\n// CONCATENATED MODULE: h:/trebor-repos/trebor-transitions/transition.js\nvar HALF = .5;\r\nvar PI = Math.PI, pow = Math.pow, sin = Math.sin;\r\nvar NEWTON_ITERATIONS = 4;\r\nvar NEWTON_MIN_SLOPE = 0.001;\r\nvar SUBDIVISION_PRECISION = 0.0000001;\r\nvar SUBDIVISION_MAX_ITERATIONS = 10;\r\nvar kSplineTableSize = 11;\r\nvar kSampleStepSize = 1 / (kSplineTableSize - 1);\r\nvar float32ArraySupported = typeof Float32Array === 'function';\r\nfunction C(aA1) { return 3 * aA1; }\r\nfunction now() { return performance.now(); }\r\nfunction B(aA1, aA2) { return C(aA2) - 6 * aA1; }\r\nfunction A(aA1, aA2) { return 1 - C(aA2) + C(aA1); }\r\nfunction calcBezier(aT, aA1, aA2) {\r\n    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\r\n}\r\nfunction getSlope(aT, aA1, aA2) {\r\n    return C(A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1));\r\n}\r\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\r\n    var currentX, currentT, i = 0;\r\n    do {\r\n        currentT = aA + (aB - aA) / 2;\r\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\r\n        if (currentX > 0) {\r\n            aB = currentT;\r\n        }\r\n        else {\r\n            aA = currentT;\r\n        }\r\n    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\r\n    return currentT;\r\n}\r\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\r\n    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\r\n        var currentSlope = getSlope(aGuessT, mX1, mX2);\r\n        if (currentSlope === 0) {\r\n            return aGuessT;\r\n        }\r\n        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\r\n        aGuessT -= currentX / currentSlope;\r\n    }\r\n    return aGuessT;\r\n}\r\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\r\n    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\r\n        throw new Error('bezier x values must be in [0, 1] range');\r\n    }\r\n    if (mX1 === mY1 && mX2 === mY2) {\r\n        return function (x) { return x; };\r\n    }\r\n    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\r\n    for (var i = 0; i < kSplineTableSize; ++i) {\r\n        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\r\n    }\r\n    function getTForX(aX) {\r\n        var currentSample = 1;\r\n        var intervalStart = 0;\r\n        var lastSample = kSplineTableSize - 1;\r\n        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\r\n            intervalStart += kSampleStepSize;\r\n        }\r\n        --currentSample;\r\n        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\r\n        var guessForT = intervalStart + dist * kSampleStepSize;\r\n        var initialSlope = getSlope(guessForT, mX1, mX2);\r\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\r\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\r\n        }\r\n        else if (initialSlope === 0) {\r\n            return guessForT;\r\n        }\r\n        else {\r\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\r\n        }\r\n    }\r\n    return function (x) {\r\n        if (x === 0)\r\n            return 0;\r\n        if (x === 1)\r\n            return 1;\r\n        return calcBezier(getTForX(x), mY1, mY2);\r\n    };\r\n}\r\nfunction bounceOut(t) {\r\n    var c = .9, a = 4 / 11, b = 8 / 11;\r\n    var ca = 4356 / 361, cb = 35442 / 1805, cc = 16061 / 1805, t2 = t * t;\r\n    return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;\r\n}\r\nfunction bounceInOut(t) {\r\n    return t < HALF ? HALF * (1 - bounceOut(1 - t * 2)) : HALF * bounceOut(t * 2 - 1) + HALF;\r\n}\r\nfunction bounceIn(t) {\r\n    return 1 - bounceOut(1 - t);\r\n}\r\nfunction elasticInOut(t) {\r\n    return t < HALF\r\n        ? HALF * sin(13 * PI / 2 * 2 * t) * pow(2, 10 * (2 * t - 1))\r\n        : HALF * sin(-13 * PI / 2 * ((2 * t - 1) + 1)) * pow(2, -10 * (2 * t - 1)) + 1;\r\n}\r\nfunction elasticIn(t) {\r\n    return sin(13 * t * PI / 2) * pow(2, 10 * (t - 1));\r\n}\r\nfunction elasticOut(t) {\r\n    return sin(-13 * (t + 1) * PI / 2) * pow(2, -10 * t) + 1;\r\n}\r\nvar snap = cubicBezier(0, 1, HALF, 1);\r\nvar easeIn = cubicBezier(.42, 0, 1, 1);\r\nvar easeOut = cubicBezier(0, 0, .58, 1);\r\nvar inOut = cubicBezier(.42, 0, .58, 1);\r\nvar linear = cubicBezier(.25, .25, .75, .75);\r\nvar backIn = cubicBezier(.6, -.28, .735, .045);\r\nvar circIn = cubicBezier(.6, .04, .98, .335);\r\nvar cubicIn = cubicBezier(.55, .055, .675, .19);\r\nvar expoIn = cubicBezier(.95, .05, .795, .035);\r\nvar quadIn = cubicBezier(.55, .085, .68, .53);\r\nvar quartIn = cubicBezier(.895, .03, .685, .22);\r\nvar quintIn = cubicBezier(.755, .05, .855, .06);\r\nvar sineIn = cubicBezier(.47, 0, .745, .715);\r\nvar backOut = cubicBezier(.175, .885, .32, 1.275);\r\nvar circOut = cubicBezier(.075, .82, .165, 1);\r\nvar cubicOut = cubicBezier(.215, .61, .355, 1);\r\nvar expoOut = cubicBezier(.19, 1, .22, 1);\r\nvar quadOut = cubicBezier(.25, .46, .45, .94);\r\nvar quartOut = cubicBezier(.165, .84, .44, 1);\r\nvar quintOut = cubicBezier(.23, 1, .32, 1);\r\nvar sineOut = cubicBezier(.39, .575, .565, 1);\r\nvar backInOut = cubicBezier(.68, -.55, .265, 1.55);\r\nvar circInOut = cubicBezier(.785, .135, .15, .86);\r\nvar cubicInOut = cubicBezier(.645, .045, .355, 1);\r\nvar expoInOut = cubicBezier(1, 0, 0, 1);\r\nvar quadInOut = cubicBezier(.455, .03, .515, .955);\r\nvar quartInOut = cubicBezier(.77, 0, .175, 1);\r\nvar quintInOut = cubicBezier(.86, 0, .07, 1);\r\nvar sineInOut = cubicBezier(.445, .05, .55, .95);\r\nfunction transition(_a) {\r\n    var _b = _a.ease, ease = _b === void 0 ? easeIn : _b, duration = _a.duration, _c = _a.loop, loop = _c === void 0 ? false : _c, _d = _a.delay, delay = _d === void 0 ? 0 : _d;\r\n    var diff = 0;\r\n    var start, change, ended;\r\n    function init() {\r\n        start = now();\r\n        !this.running && (this.running = true);\r\n        requestAnimationFrame(animate.bind(this));\r\n    }\r\n    function animate(time) {\r\n        if (this.paused || !change)\r\n            return;\r\n        var fraction = (time - start + diff) / (duration || 800);\r\n        var progress = ease(fraction > 1 ? fraction = 1 : fraction);\r\n        change(progress);\r\n        if (fraction < 1) {\r\n            requestAnimationFrame(animate.bind(this));\r\n        }\r\n        else if (loop) {\r\n            diff = 0;\r\n            init.call(this);\r\n        }\r\n        else {\r\n            this.running = false;\r\n            ended && ended();\r\n        }\r\n    }\r\n    return {\r\n        paused: false,\r\n        running: false,\r\n        on: function (event, handler) {\r\n            event === 'ended' && (ended = handler);\r\n            event === 'change' && (change = handler);\r\n        },\r\n        run: function (d, l) {\r\n            delay = l || delay || 0;\r\n            duration = d || duration || 800;\r\n            delay > 0 ? setTimeout(init.bind(this), delay) : init.call(this);\r\n        },\r\n        pause: function () {\r\n            if (!this.running)\r\n                return;\r\n            this.paused = true;\r\n            diff += now() - start;\r\n        },\r\n        play: function () {\r\n            if (!this.running)\r\n                return;\r\n            this.paused = false;\r\n            init.call(this);\r\n        }\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: h:/trebor-repos/trebor-transitions/tools.js\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\n\r\nfunction animate(options, run) {\r\n    var style = document.querySelector('[animation-style-sheet]');\r\n    if (!style) {\r\n        style = document.createElement('style');\r\n        style.setAttribute('animation-style-sheet', '');\r\n        document.head.appendChild(style);\r\n    }\r\n    var el, styleIndex;\r\n    var styleSheet = style.sheet;\r\n    var className = \"animation_\" + hash_sum_default()(run);\r\n    var _a = __assign({ delay: 0, duration: 400, ease: easeIn }, options), ease = _a.ease, delay = _a.delay, duration = _a.duration;\r\n    var inAnimation = transition({ duration: duration, delay: delay, ease: ease });\r\n    var outAnimation = transition({ duration: duration, delay: delay, ease: function (x) { return 1 - ease(1 - x); } });\r\n    function setChangeCB(node, animation) {\r\n        var args = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            args[_i - 2] = arguments[_i];\r\n        }\r\n        el = node;\r\n        var anime = animation === 'in' ? inAnimation : outAnimation;\r\n        var change = run(node);\r\n        el.classList.add(className);\r\n        anime.on('change', function (progress) {\r\n            styleSheet.cssRules.length && styleSheet.deleteRule(styleIndex);\r\n            var styleTxt = change(animation === 'in' ? progress : 1 - progress);\r\n            styleSheet.insertRule(\".\" + className + \"{\" + styleTxt + \"}\");\r\n            styleIndex = styleSheet.cssRules.length - 1;\r\n        });\r\n        anime.run.apply(anime, args);\r\n    }\r\n    return {\r\n        state: 'in',\r\n        started: false,\r\n        ended: function (handler) {\r\n            var callback = function () {\r\n                el.classList.remove(className);\r\n                handler && handler();\r\n                styleSheet.deleteRule(styleIndex);\r\n            };\r\n            inAnimation.on('ended', callback);\r\n            outAnimation.on('ended', function () {\r\n                callback();\r\n            });\r\n        },\r\n        run: function (node) {\r\n            var args = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                args[_i - 1] = arguments[_i];\r\n            }\r\n            var self = this;\r\n            if (self.state === 'in') {\r\n                self.in.apply(self, [node].concat(args));\r\n                self.state = 'out';\r\n            }\r\n            else {\r\n                self.out.apply(self, [node].concat(args));\r\n                self.state = 'in';\r\n            }\r\n        },\r\n        in: function (node) {\r\n            var args = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                args[_i - 1] = arguments[_i];\r\n            }\r\n            setChangeCB.apply(void 0, [node, 'in'].concat(args));\r\n        },\r\n        out: function (node) {\r\n            var args = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                args[_i - 1] = arguments[_i];\r\n            }\r\n            setChangeCB.apply(void 0, [node, 'out'].concat(args));\r\n        }\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: h:/trebor-repos/trebor-transitions/index.js\nvar trebor_transitions_assign = (undefined && undefined.__assign) || function () {\r\n    trebor_transitions_assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return trebor_transitions_assign.apply(this, arguments);\r\n};\r\n\r\n\r\nfunction FadeAnimation(options) {\r\n    options = options || { delay: 0, duration: 400 };\r\n    return animate(options, function (node) {\r\n        var opacity = +(getComputedStyle(node).opacity || 0);\r\n        return function (progress) { return \"opacity: \" + progress * opacity + \";\"; };\r\n    });\r\n}\r\nfunction FlyAnimation(options) {\r\n    options = options || { delay: 0, duration: 400, x: 0, y: 0, ease: cubicOut };\r\n    return animate(options, function (node) {\r\n        var opacity, transform;\r\n        var _a = trebor_transitions_assign({ x: 0, y: 0 }, options), x = _a.x, y = _a.y;\r\n        var style = getComputedStyle(node);\r\n        opacity = +(style.opacity || 0);\r\n        transform = style.transform === 'none' ? '' : (style.transform ? style.transform + \" \" : '');\r\n        return function (progress) { return \"opacity: \" + progress * opacity + \"; \" +\r\n            (\"transform: \" + transform + \"translate(\" + (1 - progress) * (x || 0) + \"px, \" + (1 - progress) * (y || 0) + \"px);\"); };\r\n    });\r\n}\r\nfunction SlideAnimation(options) {\r\n    options = options || { delay: 0, duration: 400, ease: cubicOut };\r\n    return animate(options, function (node) {\r\n        var opacity, height, paddingTop, paddingBottom, marginTop, marginBottom, borderTopWidth, borderBottomWidth;\r\n        var style = getComputedStyle(node);\r\n        opacity = +(style.opacity || 0);\r\n        height = parseFloat(style.height || '0');\r\n        marginTop = parseFloat(style.marginTop || '0');\r\n        paddingTop = parseFloat(style.paddingTop || '0');\r\n        marginBottom = parseFloat(style.marginBottom || '0');\r\n        paddingBottom = parseFloat(style.paddingBottom || '0');\r\n        borderTopWidth = parseFloat(style.borderTopWidth || '0');\r\n        borderBottomWidth = parseFloat(style.borderBottomWidth || '0');\r\n        return function (progress) { return \"overflow: hidden;\" +\r\n            (\"height: \" + progress * height + \"px;\") +\r\n            (\"margin-top: \" + progress * marginTop + \"px;\") +\r\n            (\"padding-top: \" + progress * paddingTop + \"px;\") +\r\n            (\"margin-bottom: \" + progress * marginBottom + \"px;\") +\r\n            (\"padding-bottom: \" + progress * paddingBottom + \"px;\") +\r\n            (\"border-top-width: \" + progress * borderTopWidth + \"px;\") +\r\n            (\"opacity: \" + Math.min(progress * 20, 1) * opacity + \";\") +\r\n            (\"border-bottom-width: \" + progress * borderBottomWidth + \"px;\"); };\r\n    });\r\n}\r\n\n// CONCATENATED MODULE: ./components/animation.html\n\r\n\r\nfunction ifCondition_1(_$state) {\r\n  var _$frag, div_1, txt_1, _refs;\r\n  _$frag = _$d();\r\n  _refs = _$state.$refs;\r\n  return {\r\n    type: 'if',\r\n\r\n    $create: function() {\r\n      div_1 = _$ce();\r\n      txt_1 = _$ct('Hello word!');\r\n      _$setRef(_refs, 'box', div_1);\r\n    },\r\n\r\n    $mount: function(parent, sibling) {\r\n      this.$unmount();\r\n      _$a(_$(parent), _$frag, _$(sibling));\r\n    },\r\n\r\n    $update: _$noop,\r\n\r\n    $unmount: function() {\r\n      _$a(div_1, txt_1);\r\n      _$a(_$frag, div_1);\r\n    },\r\n\r\n    $destroy: function() {\r\n      this.$unmount();\r\n      _$rr(_refs, 'box', div_1);\r\n      _$frag = div_1 = txt_1 = _refs = void 0;\r\n    }\r\n  };\r\n}\r\nfunction condition_1(_$state) {\r\n  if (_$state.visible)\r\n    return ifCondition_1(_$state);\r\n  else\r\n    return _$emptyElse();\r\n}\r\nfunction _$tplAnimation(_$state) {\r\n  var _$frag, input_1, changeEvent_1, handlerChangeEvent_1, label_1, txt_1, setTxt_1, conditionAnchor_1, conditionBlock_1;\r\n  _$frag = _$d();\r\n  changeEvent_1 = function(_$state, $event, $el) {\r\n    _$state.onChange($el.checked);\r\n  };\r\n  setTxt_1 = function() {\r\n    return 'Visible: ';\r\n  };\r\n  '+(_$state.visible)+';\r\n  '';\r\n  conditionAnchor_1 = _$ct();\r\n  return {\r\n    $create: function() {\r\n      input_1 = _$ce('input');\r\n      label_1 = _$ce('label');\r\n      txt_1 = _$ct();\r\n      txt_1.data = setTxt_1(_$state);\r\n      conditionBlock_1 = condition_1(_$state);\r\n      conditionBlock_1.$create();\r\n      _$sa(input_1, ['id', 'visible']);\r\n      _$sa(input_1, ['type', 'checkbox']);\r\n      _$al(input_1, 'change', handlerChangeEvent_1 = function(event) {\r\n        changeEvent_1(_$state, event, input_1);\r\n      });\r\n      _$sa(label_1, ['for', 'visible']);\r\n    },\r\n\r\n    $mount: function(parent, sibling) {\r\n      this.$unmount();\r\n      _$is(\r\n        'scope_2d826740',\r\n        'div {width:125px;padding:45px 0;color:white;text-align:center;background-color:black;}'\r\n      );\r\n      _$a(_$(parent), _$frag, _$(sibling));\r\n      this.$siblingEl = _$(sibling);\r\n      this.$parentEl = sibling && _$(sibling).parentElement || _$(parent);\r\n    },\r\n\r\n    $update: function(_$state) {\r\n      _$tu(txt_1, setTxt_1(_$state));\r\n      conditionBlock_1 = _$cu(conditionBlock_1, condition_1, undefined, conditionAnchor_1, _$state);\r\n    },\r\n\r\n    $unmount: function() {\r\n      _$a(_$frag, input_1);\r\n      _$a(label_1, txt_1);\r\n      _$a(_$frag, label_1);\r\n      _$a(_$frag, conditionAnchor_1);\r\n      conditionBlock_1.$mount(_$frag, conditionAnchor_1);\r\n    },\r\n\r\n    $destroy: function() {\r\n      this.$unmount();\r\n      this.$parent = null;\r\n      this.$parentEl = null;\r\n      this.$siblingEl = null;\r\n      this.$children.splice(0, this.$children.length);\r\n      _$ds('scope_2d826740');\r\n      _$rl(input_1, 'change', handlerChangeEvent_1);\r\n      conditionBlock_1.$destroy();\r\n      delete _$state.$root;\r\n      _$frag = input_1 = changeEvent_1 = handlerChangeEvent_1 = label_1 = txt_1 = setTxt_1 = conditionAnchor_1 = conditionBlock_1 = void 0;\r\n    }\r\n  };\r\n}\r\nvar animation = SlideAnimation({\r\n  y: 300,\r\n  duration: 1200\r\n});\r\nfunction Animation(_$attrs, _$parent) {\r\n  _$CompCtr.call(this, _$attrs, _$tplAnimation, {\r\n    model: {\r\n      visible: false,\r\n\r\n      onChange: function(value) {\r\n        var _this = this;\r\n        var refs = this.$refs;\r\n        animation.ended(function() {\r\n          !value && _this.$update();\r\n        });\r\n        if (value) {\r\n          this.$set('visible', value);\r\n          animation.in(refs.box);\r\n        } else {\r\n          this.visible = value;\r\n          animation.out(refs.box);\r\n        }\r\n      }\r\n    }\r\n  }, _$parent);\r\n  !_$parent && this.$create();\r\n}\r\n_$extends(Animation, _$CompCtr);\r\n/* harmony default export */ var components_animation = (Animation);\r\n\n// CONCATENATED MODULE: ./main.ts\n\r\nvar main_animation = new components_animation();\r\nmain_animation.$mount('main');\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vaDovdHJlYm9yLXJlcG9zL3RyZWJvci90b29scy9pbmRleC5qcz84MDFhIiwid2VicGFjazovLy9oOi90cmVib3ItcmVwb3MvdHJlYm9yLXRyYW5zaXRpb25zL3RyYW5zaXRpb24uanM/NzkzMiIsIndlYnBhY2s6Ly8vaDovdHJlYm9yLXJlcG9zL3RyZWJvci10cmFuc2l0aW9ucy90b29scy5qcz9hY2UyIiwid2VicGFjazovLy9oOi90cmVib3ItcmVwb3MvdHJlYm9yLXRyYW5zaXRpb25zL2luZGV4LmpzPzllYjMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9hbmltYXRpb24uaHRtbD9jZDA4Iiwid2VicGFjazovLy8uL21haW4udHM/ODI2OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msb0JBQW9CLCtCQUErQixFQUFFO0FBQzdGO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CLFVBQVUsRUFBRSxFQUFFLEVBQUU7QUFDcEU7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaURBQWlELEVBQUU7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGtDQUFrQyxFQUFFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FDekpvRDtBQUVwRCxJQUFNLGNBQVMsR0FBRyxJQUFJLG9CQUFTLEVBQUUsQ0FBQztBQUVsQyxjQUFTLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDIiwiZmlsZSI6Ii4vbWFpbi50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBQUk9QX01BUCA9IHsgcDogJ19fVFBfXycsIHY6ICd2YWx1ZScsIF86ICdfdmFsdWUnLCBzOiAnX3N1YnNjcmliZXJzJywgZTogJ19ldmVudHMnLCB3OiAnX3dhdGNoZXJzJywgaDogJ3Byb3RvdHlwZScgfTtcclxudmFyIFBST1BTID0gWyckc2xvdHMnLCAnJHJlZnMnLCAnJGZpbHRlcnMnLCAnJGRpcmVjdGl2ZXMnLCAnX2V2ZW50cycsICdfd2F0Y2hlcnMnXTtcclxudmFyIFRQUyA9IHdpbmRvd1tQUk9QX01BUC5wXSB8fCAod2luZG93W1BST1BfTUFQLnBdID0gW10pO1xyXG52YXIgXyRhc3NpZ24gPSBPYmplY3RbJ2Fzc2lnbiddIHx8IGZ1bmN0aW9uICh0KSB7XHJcbiAgICBmb3IgKHZhciBzID0gdm9pZCAwLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcylcclxuICAgICAgICAgICAgaWYgKF8kaGFzUHJvcChzLCBwKSlcclxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn07XHJcbmV4cG9ydCBmdW5jdGlvbiBfJENvbXBDdHIoYXR0cnMsIHRlbXBsYXRlLCBvcHRpb25zLCBwYXJlbnQpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIHZhciBfJHNldCA9IGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkgeyBfJGRlZihzZWxmLCBwcm9wLCB7IHZhbHVlOiB2YWx1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH07XHJcbiAgICBpZiAoIWF0dHJzKVxyXG4gICAgICAgIGF0dHJzID0ge307XHJcbiAgICBfJGUoUFJPUFMsIGZ1bmN0aW9uIChwcm9wKSB7IF8kZGVmKHNlbGYsIHByb3AsIHsgdmFsdWU6IHt9IH0pOyB9KTtcclxuICAgIF8kc2V0KCckcGFyZW50JywgcGFyZW50IHx8IG51bGwpO1xyXG4gICAgXyRzZXQoJyRjaGlsZHJlbicsIFtdKTtcclxuICAgIF8kc2V0KFBST1BfTUFQLnMsIHt9KTtcclxuICAgIF8kc2V0KCckb3B0aW9ucycsIG9wdGlvbnMpO1xyXG4gICAgdmFyIG9wdHMgPSBzZWxmLiRvcHRpb25zO1xyXG4gICAgaWYgKCFvcHRzLmF0dHJzKVxyXG4gICAgICAgIG9wdHMuYXR0cnMgPSB7fTtcclxuICAgIGlmICghb3B0cy5jaGlsZHJlbilcclxuICAgICAgICBvcHRzLmNoaWxkcmVuID0ge307XHJcbiAgICBfJGUoVFBTLCBmdW5jdGlvbiAocGx1Z2luKSB7IHBsdWdpbi5mbi5jYWxsKHNlbGYsIF8kQ29tcEN0ciwgcGx1Z2luLm9wdGlvbnMpOyB9KTtcclxuICAgIGlmIChvcHRzLmZpbHRlcnMpXHJcbiAgICAgICAgXyRhc3NpZ24oc2VsZi4kZmlsdGVycywgb3B0cy5maWx0ZXJzKTtcclxuICAgIGlmIChvcHRzLmRpcmVjdGl2ZXMpXHJcbiAgICAgICAgXyRlKG9wdHMuZGlyZWN0aXZlcywgZnVuY3Rpb24gKGRydCwgaykgeyBzZWxmLiRkaXJlY3RpdmVzW2tdID0gXyRkcnQoZHJ0KTsgfSk7XHJcbiAgICBfJGUob3B0cy5hdHRycywgZnVuY3Rpb24gKGF0dHJPcHMsIGtleSkge1xyXG4gICAgICAgIF8kZGVmKHNlbGYsIChfJGlzVHlwZShrZXksICdudW1iZXInKSA/IGF0dHJPcHMgOiBrZXkpLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF8kaXNTdHIoYXR0ck9wcykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1thdHRyT3BzXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXyRpc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlKCkgOiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghXyRoYXNQcm9wKGF0dHJzLCBrZXkpICYmIGF0dHJPcHMucmVxdWlyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJBdHRyaWJ1dGUgJ1wiICsga2V5ICsgXCInIGlzIHJlcXVpcmVkLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF8kaXNGdW5jdGlvbihhdHRyc1trZXldKSA/IGF0dHJzW2tleV0oKSA6IGF0dHJzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwICYmIF8kaGFzUHJvcChhdHRyT3BzLCAnZGVmYXVsdCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gYXR0ck9wcy5kZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfJGlzRnVuY3Rpb24oZGVmKSA/IGRlZigpIDogZGVmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXAgPSBhdHRyT3BzLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXAgJiYgIV8kaXNUeXBlKHZhbHVlLCB0eXApICYmIGF0dHJPcHMucmVxdWlyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiQXR0cmlidXRlICdcIiArIGtleSArIFwiJyBtdXN0IGJlIHR5cGUgJ1wiICsgdHlwICsgXCInLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF8kdG9UeXBlKHZhbHVlLCB2YWx1ZSA9PT0gdm9pZCAwID8gJ3VuZGVmaW5lZCcgOiB0eXAsIHNlbGYsIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwICYmIF8kaGFzUHJvcChhdHRyT3BzLCAndmFsaWRhdG9yJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZGF0b3IgPSBhdHRyT3BzLnZhbGlkYXRvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfJGlzRnVuY3Rpb24odmFsaWRhdG9yKSAmJiAhdmFsaWRhdG9yKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiQXNzaWdtZW50ICdcIiArIGtleSArIFwiJz0nXCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyBcIicgaW52YWxpZC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiJ1wiICsga2V5ICsgXCInIGlzIHJlYWQgb25seS5cIik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICB2YXIgZGF0YSA9IG9wdHMubW9kZWwgfHwge307XHJcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICBpZiAoXyRoYXNQcm9wKGRhdGEsIGtleSkpIHtcclxuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGRhdGEsIGtleSk7XHJcbiAgICAgICAgICAgIGlmIChkZXNjLnZhbHVlICYmIF8kaXNBcnJheShkZXNjLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgZGVzYy52YWx1ZSA9IG5ldyBfJExpc3QoZGVzYy52YWx1ZSwgc2VsZiwga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChkZXNjLmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXR0ZXJfMSA9IGRlc2MuZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGRlc2MuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXR0ZXJfMS5jYWxsKHNlbGYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXyRpc0FycmF5KHZhbHVlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IF8kTGlzdCh2YWx1ZSwgc2VsZiwga2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVzYy5zZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dGVyXzEgPSBkZXNjLnNldDtcclxuICAgICAgICAgICAgICAgICAgICBkZXNjLnNldCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfJGlzQXJyYXkodikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gbmV3IF8kTGlzdCh2LCBzZWxmLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXJfMS5jYWxsKHNlbGYsIHYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXyRkZWYoc2VsZiwga2V5LCBkZXNjKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcclxuICAgICAgICBfbG9vcF8xKGtleSk7XHJcbiAgICB9XHJcbiAgICB2YXIgdHBsID0gdGVtcGxhdGUoc2VsZik7XHJcbiAgICBfJGUodHBsLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xyXG4gICAgICAgIF8kZGVmKHNlbGYsIGtleSwge1xyXG4gICAgICAgICAgICB2YWx1ZTogKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBob29rID0ga2V5WzFdLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMik7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmhvb2sgPSBvcHRzW1wiYmVmb3JlXCIgKyBob29rXTtcclxuICAgICAgICAgICAgICAgIHZhciBhaG9vayA9IG9wdHNbXCJhZnRlclwiICsgaG9va107XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJob29rICYmIGJob29rLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5LnNsaWNlKDEpID09PSAndXBkYXRlJyA/IHZhbHVlLmNhbGwodGhpcywgdGhpcykgOiB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFob29rICYmIGFob29rLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KShrZXkpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIF8kZGVmKHNlbGYsICckZGF0YScsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF8kdG9QbGFpbk9iaih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBfJGlzVmFsdWVBdHRyKGF0dHIpIHtcclxuICAgIHJldHVybiBhdHRyID09PSAndmFsdWUnO1xyXG59XHJcbmZ1bmN0aW9uIF8kc3VicyhkZXAsIGxpc3RlbmVyKSB7XHJcbiAgICBpZiAoIXRoaXNbUFJPUF9NQVAuc11bZGVwXSkge1xyXG4gICAgICAgIHRoaXNbUFJPUF9NQVAuc11bZGVwXSA9IFtdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXNbUFJPUF9NQVAuc11bZGVwXS5wdXNoKGxpc3RlbmVyLmJpbmQodGhpcykpIC0gMTtcclxufVxyXG5mdW5jdGlvbiBfJGRlZihvYmosIGtleSwgZGVzYykge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCBkZXNjKTtcclxufVxyXG5fJGFzc2lnbihfJENvbXBDdHJbUFJPUF9NQVAuaF0sIHtcclxuICAgICRnZXQ6IGZ1bmN0aW9uIChwYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIF8kYWNjZXNvcih0aGlzLCBwYXRoKTtcclxuICAgIH0sXHJcbiAgICAkc2V0OiBmdW5jdGlvbiAocGF0aCwgdmFsdWUpIHtcclxuICAgICAgICBfJGFjY2Vzb3IodGhpcywgcGF0aCwgdmFsdWUpO1xyXG4gICAgfSxcclxuICAgICRvbjogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoIXRoaXNbUFJPUF9NQVAuZV1bZXZlbnRdKSB7XHJcbiAgICAgICAgICAgIHRoaXNbUFJPUF9NQVAuZV1bZXZlbnRdID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpID0gdGhpc1tQUk9QX01BUC5lXVtldmVudF0ucHVzaChoYW5kbGVyKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAkb2ZmOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpc1tQUk9QX01BUC5lXVtldmVudF0uc3BsaWNlKGkgLSAxLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgJG9uY2U6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBlID0gdGhpcy4kb24oZXZlbnQsIGZ1bmN0aW9uIChhcmdzKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXIoYXJncyk7XHJcbiAgICAgICAgICAgIGUuJG9mZigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgICRmaXJlOiBmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcclxuICAgICAgICBpZiAodGhpc1tQUk9QX01BUC5lXVtldmVudF0pIHtcclxuICAgICAgICAgICAgXyRlKHRoaXNbUFJPUF9NQVAuZV1bZXZlbnRdLCBmdW5jdGlvbiAoaGFuZGxlcikgeyBoYW5kbGVyKGRhdGEpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgJG5vdGlmeTogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIGlmICh0aGlzW1BST1BfTUFQLnNdW2tleV0pIHtcclxuICAgICAgICAgICAgXyRlKHRoaXNbUFJPUF9NQVAuc11ba2V5XSwgZnVuY3Rpb24gKHN1c2NyaWJlcikgeyBzdXNjcmliZXIoKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgICRvYnNlcnZlOiBmdW5jdGlvbiAoZGVwcywgbGlzdGVuZXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBzdWJzID0gW107XHJcbiAgICAgICAgaWYgKF8kaXNBcnJheShkZXBzKSkge1xyXG4gICAgICAgICAgICBfJGUoZGVwcywgZnVuY3Rpb24gKGRlcCkge1xyXG4gICAgICAgICAgICAgICAgc3Vicy5wdXNoKHsgc3ViOiBkZXAsIGk6IF8kc3Vicy5jYWxsKF90aGlzLCBkZXAsIGxpc3RlbmVyKSB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdWJzLnB1c2goeyBzdWI6IGRlcHMsIGk6IF8kc3Vicy5jYWxsKHRoaXMsIGRlcHMsIGxpc3RlbmVyKSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJHVub2JzZXJ2ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgXyRlKHN1YnMsIGZ1bmN0aW9uIChzdWIpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpc1tQUk9QX01BUC5zXVtzdWIuc3ViXS5zcGxpY2Uoc3ViLmksIDEpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgICR3YXRjaDogZnVuY3Rpb24gKGtleSwgd2F0Y2hlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCF0aGlzW1BST1BfTUFQLnddW2tleV0pIHtcclxuICAgICAgICAgICAgdGhpc1tQUk9QX01BUC53XVtrZXldID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpID0gdGhpc1tQUk9QX01BUC53XVtrZXldLnB1c2god2F0Y2hlci5iaW5kKHRoaXMpKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAkdW53YXRjaDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXNbUFJPUF9NQVAud11ba2V5XS5zcGxpY2UoaSAtIDEsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufSk7XHJcbnZhciBhcnJheSA9IEFycmF5W1BST1BfTUFQLmhdO1xyXG5mdW5jdGlvbiBfJHRvQXJncyhhcmdzLCBzdGFydCkge1xyXG4gICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSAwOyB9XHJcbiAgICByZXR1cm4gYXJyYXkuc2xpY2UuY2FsbChhcmdzLCBzdGFydCk7XHJcbn1cclxuZnVuY3Rpb24gXyRhcnJheVZhbHVlcyhsaXN0LCB2YWx1ZSwgcm9vdCwga2V5KSB7XHJcbiAgICBhcnJheS5wdXNoLmFwcGx5KGxpc3QsIHZhbHVlLm1hcChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCAhPT0gMClcclxuICAgICAgICAgICAgaSArPSBsaXN0Lmxlbmd0aDtcclxuICAgICAgICByZXR1cm4gIShfJGlzVHlwZSh2LCBfJExpc3QpKSAmJiBfJGlzQXJyYXkodikgPyBuZXcgXyRMaXN0KHYsIHJvb3QsIGtleSArIFwiLlwiICsgaSkgOiB2O1xyXG4gICAgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIF8kTGlzdCh2YWx1ZSwgcm9vdCwga2V5KSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICBBcnJheS5hcHBseShzZWxmLCBbdmFsdWUubGVuZ3RoXSk7XHJcbiAgICB2YXIgZGVzYyA9IHsgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IGZhbHNlLCBlbnVtZXJhYmxlOiBmYWxzZSB9O1xyXG4gICAgXyRkZWYoc2VsZiwgJ19rZXknLCBfJGFzc2lnbih7IHZhbHVlOiBrZXkgfSwgZGVzYykpO1xyXG4gICAgXyRkZWYoc2VsZiwgJ19yb290JywgXyRhc3NpZ24oeyB2YWx1ZTogcm9vdCB9LCBkZXNjKSk7XHJcbiAgICBfJGFycmF5VmFsdWVzKHNlbGYsIHZhbHVlLCByb290LCBrZXkpO1xyXG4gICAgZGVzYy53cml0YWJsZSA9IHRydWU7XHJcbiAgICBfJGRlZihzZWxmLCAnbGVuZ3RoJywgXyRhc3NpZ24oeyB2YWx1ZTogc2VsZi5sZW5ndGggfSwgZGVzYykpO1xyXG59XHJcbl8kZXh0ZW5kcyhfJExpc3QsIEFycmF5KTtcclxuWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnZmlsbCcsICd1bnNoaWZ0JywgJ3NwbGljZSddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gICAgXyRMaXN0W1BST1BfTUFQLmhdW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBvbGQgPSBzZWxmLnNsaWNlKCk7XHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICBpZiAobWV0aG9kID09PSAncHVzaCcpIHtcclxuICAgICAgICAgICAgXyRhcnJheVZhbHVlcyhzZWxmLCBfJHRvQXJncyhhcmd1bWVudHMpLCBzZWxmLl9yb290LCBzZWxmLl9rZXkpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSBzZWxmLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGFycmF5W21ldGhvZF0uYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXyRkaXNwYXRjaChzZWxmLl9yb290LCBzZWxmLl9rZXksIG9sZCwgc2VsZi5zbGljZSgpKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxufSk7XHJcbl8kTGlzdFtQUk9QX01BUC5oXS5wdWxsID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgaXRlbXMgPSBfJHRvQXJncyhhcmd1bWVudHMsIDEpO1xyXG4gICAgdmFyIGxlbmd0aCA9IHNlbGYubGVuZ3RoO1xyXG4gICAgaWYgKGluZGV4ID4gbGVuZ3RoKSB7XHJcbiAgICAgICAgbGVuZ3RoID0gaW5kZXggKyAxO1xyXG4gICAgICAgIHZhciBwdWxsID0gbmV3IEFycmF5KGluZGV4IC0gc2VsZi5sZW5ndGgpO1xyXG4gICAgICAgIHB1bGwucHVzaC5hcHBseShwdWxsLCBpdGVtcyk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYucHVzaC5hcHBseShzZWxmLCBwdWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtpbmRleCwgMV0uY29uY2F0KGl0ZW1zKSk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIF8kZGlzcGF0Y2gocm9vdCwga2V5LCBvbGRWYWwsIHZhbHVlKSB7XHJcbiAgICByb290LiRub3RpZnkoa2V5KTtcclxuICAgIGlmIChyb290W1BST1BfTUFQLnddW2tleV0pIHtcclxuICAgICAgICBfJGUocm9vdFtQUk9QX01BUC53XVtrZXldLCBmdW5jdGlvbiAod2F0Y2hlcikgeyB3YXRjaGVyKG9sZFZhbCwgdmFsdWUpOyB9KTtcclxuICAgIH1cclxuICAgIHJvb3QuJHVwZGF0ZSgpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBfJGV4dGVuZHMoY3RvciwgZXh0cykge1xyXG4gICAgY3RvclsncGx1Z2luJ10gPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcclxuICAgICAgICBUUFMucHVzaCh7IG9wdGlvbnM6IG9wdGlvbnMsIGZuOiBmbiB9KTtcclxuICAgIH07XHJcbiAgICBjdG9yW1BST1BfTUFQLmhdID0gT2JqZWN0LmNyZWF0ZShleHRzW1BST1BfTUFQLmhdKTtcclxuICAgIGN0b3JbUFJPUF9NQVAuaF0uY29uc3RydWN0b3IgPSBjdG9yO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBfJGlzVHlwZSh2YWx1ZSwgdHlwZSkge1xyXG4gICAgcmV0dXJuIF8kdHlwZSh0eXBlKSA9PT0gJ3N0cmluZycgPyB0eXBlLnNwbGl0KCd8Jykuc29tZShmdW5jdGlvbiAodCkgeyByZXR1cm4gdC50cmltKCkgPT09IF8kdHlwZSh2YWx1ZSk7IH0pIDogdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xyXG59XHJcbmZ1bmN0aW9uIF8kYXBwbHkoY2FsbGVlLCBhcmdzLCBnbG9icywgdGhpc0FyZykge1xyXG4gICAgaWYgKHRoaXNBcmcgPT09IHZvaWQgMCkgeyB0aGlzQXJnID0gbnVsbDsgfVxyXG4gICAgcmV0dXJuIGNhbGxlZS5hcHBseSh0aGlzQXJnLCBhcmdzLmNvbmNhdChnbG9icykpO1xyXG59XHJcbmZ1bmN0aW9uIF8kaXNPYmplY3Qob2JqKSB7XHJcbiAgICByZXR1cm4gXyRpc1R5cGUob2JqLCAnb2JqZWN0Jyk7XHJcbn1cclxuZnVuY3Rpb24gXyRpc0FycmF5KG9iaikge1xyXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkgPyBBcnJheS5pc0FycmF5KG9iaikgOiBfJGlzVHlwZShvYmosICdhcnJheScpO1xyXG59XHJcbmZ1bmN0aW9uIF8kaXNGdW5jdGlvbihvYmopIHtcclxuICAgIHJldHVybiBfJGlzVHlwZShvYmosICdmdW5jdGlvbicpO1xyXG59XHJcbmZ1bmN0aW9uIF8kaXNTdHIob2JqKSB7XHJcbiAgICByZXR1cm4gXyRpc1R5cGUob2JqLCAnc3RyaW5nJyk7XHJcbn1cclxuZnVuY3Rpb24gXyR0b1R5cGUodmFsdWUsIHR5cGUsIHJvb3QsIGtleSkge1xyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSAnZGF0ZSc6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICAgICAgcmV0dXJuIF8kdG9TdHIodmFsdWUpO1xyXG4gICAgICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgICAgICAgIHJldHVybiArdmFsdWU7XHJcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XHJcbiAgICAgICAgICAgIHJldHVybiBfJGlzU3RyKHZhbHVlKSAmJiAhdmFsdWUgPyB0cnVlIDogISF2YWx1ZTtcclxuICAgICAgICBjYXNlICdhcnJheSc6XHJcbiAgICAgICAgICAgIHJldHVybiBfJGlzVHlwZSh2YWx1ZSwgXyRMaXN0KSA/IHZhbHVlIDogbmV3IF8kTGlzdCh2YWx1ZSwgcm9vdCwga2V5KTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gXyR0eXBlKG9iaikge1xyXG4gICAgcmV0dXJuIC8gKFxcdyspLy5leGVjKCh7fSkudG9TdHJpbmcuY2FsbChvYmopKVsxXS50b0xvd2VyQ2FzZSgpO1xyXG59XHJcbmZ1bmN0aW9uIF8kaGFzUHJvcChvYmosIHByb3ApIHtcclxuICAgIHJldHVybiBvYmouaGFzT3duUHJvcGVydHkocHJvcCk7XHJcbn1cclxuZnVuY3Rpb24gXyRkcnQoZGQpIHtcclxuICAgIHZhciBoYXNQcm9wID0gZnVuY3Rpb24gKHByb3AsIGluc3RhbmNlLCBvcHRpb25zLCBlbGVtZW50KSB7IHJldHVybiBfJGlzT2JqZWN0KGRkKSAmJiBkZFtwcm9wXSAmJiBkZFtwcm9wXShpbnN0YW5jZSwgb3B0aW9ucywgZWxlbWVudCk7IH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgICRpbml0OiBmdW5jdGlvbiAoaW5zdGFuY2UsIG9wdGlvbnMsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaGFzUHJvcCgnJGluaXQnLCBpbnN0YW5jZSwgb3B0aW9ucywgZWxlbWVudCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAkaW5zZXJ0ZWQ6IGZ1bmN0aW9uIChpbnN0YW5jZSwgb3B0aW9ucywgZWxlbWVudCkge1xyXG4gICAgICAgICAgICBoYXNQcm9wKCckaW5zZXJ0ZWQnLCBpbnN0YW5jZSwgb3B0aW9ucywgZWxlbWVudCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAkdXBkYXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG9wdGlvbnMsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKF8kaXNGdW5jdGlvbihkZCkpIHtcclxuICAgICAgICAgICAgICAgIGRkKGluc3RhbmNlLCBvcHRpb25zLCBlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhhc1Byb3AoJyR1cGRhdGUnLCBpbnN0YW5jZSwgb3B0aW9ucywgZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICRkZXN0cm95OiBmdW5jdGlvbiAoaW5zdGFuY2UsIG9wdGlvbnMsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaGFzUHJvcCgnJGRlc3Ryb3knLCBpbnN0YW5jZSwgb3B0aW9ucywgZWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gXyRub29wKCkgeyB9XHJcbmV4cG9ydCBmdW5jdGlvbiBfJGFkZChpbnN0LCBDaGlsZCwgYXR0cnMpIHtcclxuICAgIHZhciBjaGlsZCA9IG51bGw7XHJcbiAgICBpZiAoQ2hpbGQpIHtcclxuICAgICAgICBjaGlsZCA9IG5ldyBDaGlsZChhdHRycywgaW5zdCk7XHJcbiAgICAgICAgaW5zdC4kY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2hpbGQ7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIF8kcmVtb3ZlKGluc3QsIGNoaWxkKSB7XHJcbiAgICB2YXIgaW5kZXggPSBpbnN0LiRjaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcclxuICAgIGluZGV4ID49IDAgJiYgaW5zdC4kY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gXyR0b1N0cihvYmopIHtcclxuICAgIHZhciBzdHIgPSBfJHR5cGUob2JqKTtcclxuICAgIHJldHVybiAhL251bGx8dW5kZWZpbmVkLy50ZXN0KHN0cikgPyBvYmoudG9TdHJpbmcoKSA6IHN0cjtcclxufVxyXG5mdW5jdGlvbiBfJHRvUGxhaW5PYmoob2JqKSB7XHJcbiAgICB2YXIgZGF0YSA9IHt9O1xyXG4gICAgXyRlKF8kaXNPYmplY3Qob2JqKSA/IG9iaiA6IHt9LCBmdW5jdGlvbiAoX3YsIGspIHtcclxuICAgICAgICBpZiAoa1swXSAhPT0gJyQnICYmICFfJGlzRnVuY3Rpb24ob2JqW2tdKSkge1xyXG4gICAgICAgICAgICBpZiAoXyRpc1R5cGUob2JqW2tdLCBfJExpc3QpKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhW2tdID0gb2JqW2tdLm1hcChfJHRvUGxhaW5PYmopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF8kaXNPYmplY3Qob2JqW2tdKSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YVtrXSA9IF8kdG9QbGFpbk9iaihvYmpba10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGF0YVtrXSA9IG9ialtrXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIF8kaXNPYmplY3Qob2JqKSA/IGRhdGEgOiBvYmo7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIF8kc2V0UmVmKHJlZnMsIHByb3AsIG5vZGUpIHtcclxuICAgIGlmICghXyRoYXNQcm9wKHJlZnMsIHByb3ApKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlXzEgPSBbXTtcclxuICAgICAgICBfJGRlZihyZWZzLCBwcm9wLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWVfMS5sZW5ndGggPD0gMSA/IHZhbHVlXzFbMF0gOiB2YWx1ZV8xOyB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdmFsICYmICF+dmFsdWVfMS5pbmRleE9mKHZhbCkgJiYgdmFsdWVfMS5wdXNoKHZhbCk7IH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVmc1twcm9wXSA9IG5vZGU7XHJcbn1cclxuZnVuY3Rpb24gXyRhY2Nlc29yKG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcclxuICAgIHJldHVybiBwYXRoLnNwbGl0KCcuJykucmVkdWNlKGZ1bmN0aW9uIChvYmosIGtleSwgaSwgYXJyKSB7XHJcbiAgICAgICAgaWYgKF8kaXNUeXBlKHZhbHVlLCAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBhcnIuc3BsaWNlKDAsIGFyci5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgPiAwICYmIG9iaiA9PT0gbnVsbCA/IG9iaiA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGkgPT09IGFyci5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXyRpc1R5cGUob2JqLCBfJExpc3QpICYmIF8kdG9TdHIoK2tleSkgPT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9iai5wdWxsKCtrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvbGRWYWwgPSBvYmpba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9ICFfJGlzVHlwZSh2YWx1ZSwgXyRMaXN0KSAmJiBfJGlzQXJyYXkodmFsdWUpID8gbmV3IF8kTGlzdCh2YWx1ZSwgb2JqZWN0LCBrZXkpIDogdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgXyRkaXNwYXRjaChvYmplY3QsIHBhdGgsIG9sZFZhbCwgb2JqW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFfJGlzT2JqZWN0KG9ialtrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqID8gb2JqW2tleV0gOiBudWxsO1xyXG4gICAgfSwgb2JqZWN0KTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gXyRlbXB0eUVsc2UoKSB7XHJcbiAgICByZXR1cm4geyB0eXBlOiAnZW1wdHktZWxzZScsICRjcmVhdGU6IF8kbm9vcCwgJG1vdW50OiBfJG5vb3AsICR1cGRhdGU6IF8kbm9vcCwgJGRlc3Ryb3k6IF8kbm9vcCB9O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBfJGlzS2V5KGV2ZW50LCBrZXkpIHtcclxuICAgIHJldHVybiBldmVudC5rZXkudG9Mb3dlckNhc2UoKSA9PT0ga2V5IHx8ICEhZXZlbnRba2V5ICsgXCJLZXlcIl07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIF8kYmluZEdyb3VwKGlucHV0LCBzZWxlY3Rpb24pIHtcclxuICAgIHZhciBfdmFsdWUgPSBfJGd2KGlucHV0KTtcclxuICAgIHZhciBfJGluZGV4ID0gc2VsZWN0aW9uLmluZGV4T2YoX3ZhbHVlKTtcclxuICAgIGlucHV0LmNoZWNrZWQgJiYgIX5fJGluZGV4ID8gc2VsZWN0aW9uLnB1c2goX3ZhbHVlKSA6IHNlbGVjdGlvbi5zcGxpY2UoXyRpbmRleCwgMSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIF8kYmluZE11bHRpU2VsZWN0KHNlbGVjdCwgc2VsZWN0aW9ucykge1xyXG4gICAgaWYgKCFzZWxlY3Rpb25zLmxlbmd0aClcclxuICAgICAgICByZXR1cm47XHJcbiAgICB2YXIgb3B0aW9ucyA9IHNlbGVjdC5vcHRpb25zO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9ICEhfnNlbGVjdGlvbnMuaW5kZXhPZihfJGd2KG9wdGlvbnNbaV0pKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gXyR1cGRhdGVNdWx0aVNlbGVjdChzZWxlY3QsIG9iaiwgcHJvcCkge1xyXG4gICAgdmFyIGl0ZW1zID0gW107XHJcbiAgICB2YXIgc2VsZWN0aW9uID0gb2JqW3Byb3BdO1xyXG4gICAgdmFyIHNlbGVjdGVkT3B0aW9ucyA9IHNlbGVjdC5zZWxlY3RlZE9wdGlvbnM7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkT3B0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGl0ZW1zLnB1c2goXyRndihzZWxlY3RlZE9wdGlvbnNbaV0pKTtcclxuICAgIH1cclxuICAgIG9ialtwcm9wXSA9IG5ldyBfJExpc3QoaXRlbXMsIHNlbGVjdGlvblsnX3Jvb3QnXSwgc2VsZWN0aW9uWydfa2V5J10pO1xyXG4gICAgb2JqLiR1cGRhdGUoKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gXyQoc2VsZWN0b3IsIHBhcmVudCkge1xyXG4gICAgcmV0dXJuIF8kaXNTdHIoc2VsZWN0b3IpID8gKHBhcmVudCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgOiBzZWxlY3RvcjtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gXyRkKCkge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gXyRhKHBhcmVudCwgY2hpbGQsIHNpYmxpbmcpIHtcclxuICAgIGlmIChfJGlzVHlwZShzaWJsaW5nLCAnYm9vbGVhbicpICYmIHNpYmxpbmcpXHJcbiAgICAgICAgcGFyZW50LnBhcmVudEVsZW1lbnQucmVwbGFjZUNoaWxkKGNoaWxkLCBwYXJlbnQpO1xyXG4gICAgZWxzZSBpZiAoIXNpYmxpbmcpXHJcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcclxuICAgIGVsc2VcclxuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBzaWJsaW5nKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gXyRhcyhzb3VyY2UsIGRlc3QpIHtcclxuICAgIHZhciBjaGlsZE5vZGVzID0gc291cmNlLmNoaWxkTm9kZXMsIGF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIF8kYShkZXN0LCBjaGlsZE5vZGVzW2ldKTtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBhdHRyID0gYXR0cmlidXRlc1tpXTtcclxuICAgICAgICBkZXN0LnNldEF0dHJpYnV0ZU5TKHNvdXJjZS5uYW1lc3BhY2VVUkksIGF0dHIubmFtZSwgYXR0ci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBzb3VyY2UucGFyZW50RWxlbWVudC5yZXBsYWNlQ2hpbGQoZGVzdCwgc291cmNlKTtcclxuICAgIHJldHVybiBkZXN0O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBfJHIoZWwsIHBhcmVudCkge1xyXG4gICAgdmFyIHJvb3QgPSBwYXJlbnQgfHwgZWwucGFyZW50RWxlbWVudDtcclxuICAgIGlmIChyb290KVxyXG4gICAgICAgIHJvb3QucmVtb3ZlQ2hpbGQoZWwpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBfJGNlKHRhZ05hbWUpIHtcclxuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUgfHwgJ2RpdicpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBfJGNzZSh0YWdOYW1lKSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIHRhZ05hbWUgfHwgJ3N2ZycpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBfJGN0KGNvbnRlbnQpIHtcclxuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb250ZW50IHx8ICcnKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gXyRjbShjb250ZW50KSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChjb250ZW50IHx8ICcnKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gXyRzYShlbCwgYXR0ckFuZFZhbHVlKSB7XHJcbiAgICB2YXIgYXR0ciA9IGF0dHJBbmRWYWx1ZVswXSwgdmFsdWUgPSBhdHRyQW5kVmFsdWVbMV07XHJcbiAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgXyR0b1N0cih2YWx1ZSkpO1xyXG4gICAgaWYgKF8kaXNWYWx1ZUF0dHIoYXR0cikgJiYgIV8kaXNTdHIodmFsdWUpKVxyXG4gICAgICAgIGVsW1BST1BfTUFQLl9dID0gdmFsdWU7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIF8kZ2EoZWwsIGF0dHIpIHtcclxuICAgIHJldHVybiBfJGlzVmFsdWVBdHRyKGF0dHIpID8gXyRndihlbCkgOiBlbC5nZXRBdHRyaWJ1dGUoYXR0cik7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIF8kZ3YoZWwpIHtcclxuICAgIHJldHVybiBfJGhhc1Byb3AoZWwsIFBST1BfTUFQLl8pID8gZWxbUFJPUF9NQVAuX10gOiBlbFtQUk9QX01BUC52XTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gXyRhbChlbCwgZXZlbnQsIGhhbmRsZXIpIHtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGZhbHNlKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gXyR1bChlbCwgZXZlbnQsIG9sZEhhbmRsZXIsIG5ld0hhbmRsZXIpIHtcclxuICAgIF8kcmwoZWwsIGV2ZW50LCBvbGRIYW5kbGVyKTtcclxuICAgIF8kYWwoZWwsIGV2ZW50LCBvbGRIYW5kbGVyID0gbmV3SGFuZGxlcik7XHJcbiAgICByZXR1cm4gb2xkSGFuZGxlcjtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gXyRybChlbCwgZXZlbnQsIGhhbmRsZXIpIHtcclxuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGZhbHNlKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gXyRiYyh2YWx1ZSkge1xyXG4gICAgdmFyIGNsYXNzZXMgPSAnJztcclxuICAgIGlmIChfJGlzU3RyKHZhbHVlKSkge1xyXG4gICAgICAgIGNsYXNzZXMgKz0gXCIgXCIgKyB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKF8kaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBjbGFzc2VzID0gdmFsdWUubWFwKF8kYmMpLmpvaW4oJyAnKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKF8kaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKVxyXG4gICAgICAgICAgICBpZiAoXyRoYXNQcm9wKHZhbHVlLCBrZXkpICYmIHZhbHVlW2tleV0pXHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzICs9IFwiIFwiICsga2V5O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNsYXNzZXMudHJpbSgpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBfJGJzKHZhbHVlKSB7XHJcbiAgICB2YXIgZWwgPSBfJGNlKCk7XHJcbiAgICBpZiAoXyRpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICB2YXIgc3R5bGVfMSA9IGVsLnN0eWxlO1xyXG4gICAgICAgIF8kZSh2YWx1ZSwgZnVuY3Rpb24gKHZhbCwgcHJvcCkge1xyXG4gICAgICAgICAgICBpZiAodmFsICE9PSBzdHlsZV8xW3Byb3BdKVxyXG4gICAgICAgICAgICAgICAgc3R5bGVfMVtwcm9wXSA9IHZhbDtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gc3R5bGVfMS5jc3NUZXh0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoXyRpc1N0cih2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIF8kY3UoYmxvY2ssIGNvbmRpdGlvbiwgcGFyZW50LCBhbmNob3IsIGluc3QpIHtcclxuICAgIHZhciBnbG9icyA9IF8kdG9BcmdzKGFyZ3VtZW50cywgNSk7XHJcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2sudHlwZSA9PT0gXyRhcHBseShjb25kaXRpb24sIFtpbnN0XSwgZ2xvYnMpLnR5cGUpIHtcclxuICAgICAgICBfJGFwcGx5KGJsb2NrLiR1cGRhdGUsIFtpbnN0XSwgZ2xvYnMsIGJsb2NrKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGJsb2NrICYmIGJsb2NrLiRkZXN0cm95KCk7XHJcbiAgICAgICAgYmxvY2sgPSBfJGFwcGx5KGNvbmRpdGlvbiwgW2luc3RdLCBnbG9icyk7XHJcbiAgICAgICAgYmxvY2suJGNyZWF0ZSgpO1xyXG4gICAgICAgIGJsb2NrLiRtb3VudChwYXJlbnQgfHwgaW5zdC4kcGFyZW50RWwsIGFuY2hvcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYmxvY2s7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIF8kYmJhKGVsLCBhdHRyQW5kVmFsdWUpIHtcclxuICAgIHZhciBhdHRyID0gYXR0ckFuZFZhbHVlWzBdLCB2YWx1ZSA9IGF0dHJBbmRWYWx1ZVsxXTtcclxuICAgIGVsW2F0dHJdID0gdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gZmFsc2UgPyAoZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpLCBmYWxzZSkgOiAoXyRzYShlbCwgW2F0dHIsICcnXSksIHRydWUpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBfJGJ1KGVsLCBiaW5kaW5nKSB7XHJcbiAgICB2YXIgYXR0ciA9IGJpbmRpbmdbMF0sIHZhbHVlID0gYmluZGluZ1sxXTtcclxuICAgIHZhciBfdmFsdWUgPSBfJHRvU3RyKHZhbHVlKTtcclxuICAgIGlmIChfJGlzVmFsdWVBdHRyKGF0dHIpKSB7XHJcbiAgICAgICAgaWYgKGVsW2F0dHJdICE9PSBfdmFsdWUpXHJcbiAgICAgICAgICAgIGVsW2F0dHJdID0gX3ZhbHVlO1xyXG4gICAgICAgIGVsW1BST1BfTUFQLl9dID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChfJGdhKGVsLCBhdHRyKSAhPT0gX3ZhbHVlKSB7XHJcbiAgICAgICAgXyRzYShlbCwgW2F0dHIsIF92YWx1ZV0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBfJHR1KHRleHQsIHZhbHVlKSB7XHJcbiAgICBpZiAodGV4dC5kYXRhICE9PSAodmFsdWUgPSBfJHRvU3RyKHZhbHVlKSkpXHJcbiAgICAgICAgdGV4dC5kYXRhID0gdmFsdWU7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIF8kbnUobm9kZSwgdGFnKSB7XHJcbiAgICByZXR1cm4gdGFnLnRvVXBwZXJDYXNlKCkgIT09IG5vZGUudGFnTmFtZSA/IF8kYXMobm9kZSwgXyRjZSh0YWcpKSA6IG5vZGU7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIF8kcnIocmVmcywgcHJvcCwgbm9kZSkge1xyXG4gICAgdmFyIG5vZGVzID0gcmVmc1twcm9wXTtcclxuICAgIF8kaXNBcnJheShub2RlcykgPyByZWZzW3Byb3BdLnNwbGljZShub2Rlcy5pbmRleE9mKG5vZGUpLCAxKSA6IChkZWxldGUgcmVmc1twcm9wXSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIF8kaHUobm9kZSwgdmFsdWUpIHtcclxuICAgIGlmIChub2RlLmlubmVySFRNTCAhPT0gKHZhbHVlID0gXyR0b1N0cih2YWx1ZSkpKVxyXG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gdmFsdWU7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIF8kcHUocGFyZW50LCBDdG9yLCBpbnN0LCB2YWx1ZSwgYXR0cnMsIGVsLCBzaWJsaW5nKSB7XHJcbiAgICBpZiAodmFsdWUgPT09IEN0b3IpIHtcclxuICAgICAgICBpbnN0ICYmIGluc3QuJHVwZGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgQ3RvciA9IHZhbHVlO1xyXG4gICAgICAgIGlmIChpbnN0KSB7XHJcbiAgICAgICAgICAgIGluc3QuJGRlc3Ryb3koKTtcclxuICAgICAgICAgICAgXyRyZW1vdmUocGFyZW50LCBpbnN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluc3QpIHtcclxuICAgICAgICAgICAgaW5zdCA9IF8kYWRkKHBhcmVudCwgQ3RvciwgYXR0cnMpO1xyXG4gICAgICAgICAgICBpbnN0LiRjcmVhdGUoKTtcclxuICAgICAgICAgICAgaW5zdC4kbW91bnQoZWwsIHNpYmxpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbaW5zdCwgQ3Rvcl07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIF8kZihyb290LCBvYmosIGxvb3ApIHtcclxuICAgIHZhciBpdGVtcyA9IHt9LCBsb29wUGFyZW50LCBsb29wU2libGluZztcclxuICAgIHZhciBnbG9icyA9IF8kdG9BcmdzKGFyZ3VtZW50cywgMyk7XHJcbiAgICBfJGUob2JqLCBmdW5jdGlvbiAoaXRlbSwgaSwgaW5kZXgpIHsgaXRlbXNbaV0gPSBfJGFwcGx5KGxvb3AsIFtyb290LCBpdGVtLCBpLCBpbmRleF0sIGdsb2JzKTsgfSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgICRjcmVhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgXyRlKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkgeyBpdGVtLiRjcmVhdGUoKTsgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAkbW91bnQ6IGZ1bmN0aW9uIChwYXJlbnQsIHNpYmxpbmcpIHtcclxuICAgICAgICAgICAgbG9vcFBhcmVudCA9IF8kKHBhcmVudCk7XHJcbiAgICAgICAgICAgIGxvb3BTaWJsaW5nID0gXyQoc2libGluZyk7XHJcbiAgICAgICAgICAgIF8kZShpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHsgaXRlbS4kbW91bnQobG9vcFBhcmVudCwgbG9vcFNpYmxpbmcpOyB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgICR1cGRhdGU6IGZ1bmN0aW9uIChyb290LCBvYmopIHtcclxuICAgICAgICAgICAgdmFyIGdsb2JzID0gXyR0b0FyZ3MoYXJndW1lbnRzLCAyKTtcclxuICAgICAgICAgICAgXyRlKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSwgaSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvYmpbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBfJGFwcGx5KGl0ZW0uJHVwZGF0ZSwgW3Jvb3QsIG9ialtpXSwgaSwgaW5kZXhdLCBnbG9icywgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLiRkZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW1zW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgXyRlKG9iaiwgZnVuY3Rpb24gKGl0ZW0sIGksIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1zW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0gPSBfJGFwcGx5KGxvb3AsIFtyb290LCBpdGVtLCBpLCBpbmRleF0sIGdsb2JzKTtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXS4kY3JlYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0uJG1vdW50KGxvb3BQYXJlbnQsIGxvb3BTaWJsaW5nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAkZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfJGUoaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7IGl0ZW0uJGRlc3Ryb3koKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gXyRlKG9iaiwgY2IpIHtcclxuICAgIHZhciBpID0gMDtcclxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoXyRoYXNQcm9wKG9iaiwga2V5KSkge1xyXG4gICAgICAgICAgICBjYihvYmpba2V5XSwgKGlzTmFOKCtrZXkpID8ga2V5IDogK2tleSksIGkrKyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBfJGlzKGlkLCBjc3MpIHtcclxuICAgIHZhciBpc05ldyA9IGZhbHNlO1xyXG4gICAgdmFyIHN0eWxlID0gXyQoXCIjXCIgKyBpZCwgZG9jdW1lbnQuaGVhZCk7XHJcbiAgICBpZiAoIXN0eWxlKSB7XHJcbiAgICAgICAgaXNOZXcgPSB0cnVlO1xyXG4gICAgICAgIHN0eWxlID0gXyRjZSgnc3R5bGUnKTtcclxuICAgICAgICBzdHlsZS5pZCA9IGlkO1xyXG4gICAgICAgIF8kc2Eoc3R5bGUsIFsncmVmcycsIDFdKTtcclxuICAgIH1cclxuICAgIGlmIChzdHlsZS50ZXh0Q29udGVudCAhPT0gY3NzKSB7XHJcbiAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBjc3M7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNOZXcpIHtcclxuICAgICAgICBfJGEoZG9jdW1lbnQuaGVhZCwgc3R5bGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGNvdW50ID0gK18kZ2Eoc3R5bGUsICdyZWZzJyk7XHJcbiAgICAgICAgXyRzYShzdHlsZSwgWydyZWZzJywgKytjb3VudF0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBfJGRzKGlkKSB7XHJcbiAgICB2YXIgc3R5bGUgPSBfJChcIiNcIiArIGlkLCBkb2N1bWVudC5oZWFkKTtcclxuICAgIGlmIChzdHlsZSkge1xyXG4gICAgICAgIHZhciBjb3VudCA9ICtfJGdhKHN0eWxlLCAncmVmcycpO1xyXG4gICAgICAgIGlmICgtLWNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIF8kcihzdHlsZSwgZG9jdW1lbnQuaGVhZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfJHNhKHN0eWxlLCBbJ3JlZnMnLCBjb3VudF0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJ2YXIgSEFMRiA9IC41O1xyXG52YXIgUEkgPSBNYXRoLlBJLCBwb3cgPSBNYXRoLnBvdywgc2luID0gTWF0aC5zaW47XHJcbnZhciBORVdUT05fSVRFUkFUSU9OUyA9IDQ7XHJcbnZhciBORVdUT05fTUlOX1NMT1BFID0gMC4wMDE7XHJcbnZhciBTVUJESVZJU0lPTl9QUkVDSVNJT04gPSAwLjAwMDAwMDE7XHJcbnZhciBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwO1xyXG52YXIga1NwbGluZVRhYmxlU2l6ZSA9IDExO1xyXG52YXIga1NhbXBsZVN0ZXBTaXplID0gMSAvIChrU3BsaW5lVGFibGVTaXplIC0gMSk7XHJcbnZhciBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAnZnVuY3Rpb24nO1xyXG5mdW5jdGlvbiBDKGFBMSkgeyByZXR1cm4gMyAqIGFBMTsgfVxyXG5mdW5jdGlvbiBub3coKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfVxyXG5mdW5jdGlvbiBCKGFBMSwgYUEyKSB7IHJldHVybiBDKGFBMikgLSA2ICogYUExOyB9XHJcbmZ1bmN0aW9uIEEoYUExLCBhQTIpIHsgcmV0dXJuIDEgLSBDKGFBMikgKyBDKGFBMSk7IH1cclxuZnVuY3Rpb24gY2FsY0JlemllcihhVCwgYUExLCBhQTIpIHtcclxuICAgIHJldHVybiAoKEEoYUExLCBhQTIpICogYVQgKyBCKGFBMSwgYUEyKSkgKiBhVCArIEMoYUExKSkgKiBhVDtcclxufVxyXG5mdW5jdGlvbiBnZXRTbG9wZShhVCwgYUExLCBhQTIpIHtcclxuICAgIHJldHVybiBDKEEoYUExLCBhQTIpICogYVQgKiBhVCArIDIgKiBCKGFBMSwgYUEyKSAqIGFUICsgQyhhQTEpKTtcclxufVxyXG5mdW5jdGlvbiBiaW5hcnlTdWJkaXZpZGUoYVgsIGFBLCBhQiwgbVgxLCBtWDIpIHtcclxuICAgIHZhciBjdXJyZW50WCwgY3VycmVudFQsIGkgPSAwO1xyXG4gICAgZG8ge1xyXG4gICAgICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyO1xyXG4gICAgICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRYID4gMCkge1xyXG4gICAgICAgICAgICBhQiA9IGN1cnJlbnRUO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYUEgPSBjdXJyZW50VDtcclxuICAgICAgICB9XHJcbiAgICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBTVUJESVZJU0lPTl9QUkVDSVNJT04gJiYgKytpIDwgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMpO1xyXG4gICAgcmV0dXJuIGN1cnJlbnRUO1xyXG59XHJcbmZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NULCBtWDEsIG1YMikge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBORVdUT05fSVRFUkFUSU9OUzsgKytpKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRTbG9wZSA9IGdldFNsb3BlKGFHdWVzc1QsIG1YMSwgbVgyKTtcclxuICAgICAgICBpZiAoY3VycmVudFNsb3BlID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhR3Vlc3NUO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xyXG4gICAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYUd1ZXNzVDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY3ViaWNCZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XHJcbiAgICBpZiAoISgwIDw9IG1YMSAmJiBtWDEgPD0gMSAmJiAwIDw9IG1YMiAmJiBtWDIgPD0gMSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JlemllciB4IHZhbHVlcyBtdXN0IGJlIGluIFswLCAxXSByYW5nZScpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9O1xyXG4gICAgfVxyXG4gICAgdmFyIHNhbXBsZVZhbHVlcyA9IGZsb2F0MzJBcnJheVN1cHBvcnRlZCA/IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSkgOiBuZXcgQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xyXG4gICAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0VEZvclgoYVgpIHtcclxuICAgICAgICB2YXIgY3VycmVudFNhbXBsZSA9IDE7XHJcbiAgICAgICAgdmFyIGludGVydmFsU3RhcnQgPSAwO1xyXG4gICAgICAgIHZhciBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XHJcbiAgICAgICAgZm9yICg7IGN1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcclxuICAgICAgICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC0tY3VycmVudFNhbXBsZTtcclxuICAgICAgICB2YXIgZGlzdCA9IChhWCAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAoc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSk7XHJcbiAgICAgICAgdmFyIGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICoga1NhbXBsZVN0ZXBTaXplO1xyXG4gICAgICAgIHZhciBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcclxuICAgICAgICBpZiAoaW5pdGlhbFNsb3BlID49IE5FV1RPTl9NSU5fU0xPUEUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQsIG1YMSwgbVgyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW5pdGlhbFNsb3BlID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBndWVzc0ZvclQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYmluYXJ5U3ViZGl2aWRlKGFYLCBpbnRlcnZhbFN0YXJ0LCBpbnRlcnZhbFN0YXJ0ICsga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgaWYgKHggPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIGlmICh4ID09PSAxKVxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICByZXR1cm4gY2FsY0JlemllcihnZXRURm9yWCh4KSwgbVkxLCBtWTIpO1xyXG4gICAgfTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gYm91bmNlT3V0KHQpIHtcclxuICAgIHZhciBjID0gLjksIGEgPSA0IC8gMTEsIGIgPSA4IC8gMTE7XHJcbiAgICB2YXIgY2EgPSA0MzU2IC8gMzYxLCBjYiA9IDM1NDQyIC8gMTgwNSwgY2MgPSAxNjA2MSAvIDE4MDUsIHQyID0gdCAqIHQ7XHJcbiAgICByZXR1cm4gdCA8IGEgPyA3LjU2MjUgKiB0MiA6IHQgPCBiID8gOS4wNzUgKiB0MiAtIDkuOSAqIHQgKyAzLjQgOiB0IDwgYyA/IGNhICogdDIgLSBjYiAqIHQgKyBjYyA6IDEwLjggKiB0ICogdCAtIDIwLjUyICogdCArIDEwLjcyO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBib3VuY2VJbk91dCh0KSB7XHJcbiAgICByZXR1cm4gdCA8IEhBTEYgPyBIQUxGICogKDEgLSBib3VuY2VPdXQoMSAtIHQgKiAyKSkgOiBIQUxGICogYm91bmNlT3V0KHQgKiAyIC0gMSkgKyBIQUxGO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBib3VuY2VJbih0KSB7XHJcbiAgICByZXR1cm4gMSAtIGJvdW5jZU91dCgxIC0gdCk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGVsYXN0aWNJbk91dCh0KSB7XHJcbiAgICByZXR1cm4gdCA8IEhBTEZcclxuICAgICAgICA/IEhBTEYgKiBzaW4oMTMgKiBQSSAvIDIgKiAyICogdCkgKiBwb3coMiwgMTAgKiAoMiAqIHQgLSAxKSlcclxuICAgICAgICA6IEhBTEYgKiBzaW4oLTEzICogUEkgLyAyICogKCgyICogdCAtIDEpICsgMSkpICogcG93KDIsIC0xMCAqICgyICogdCAtIDEpKSArIDE7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGVsYXN0aWNJbih0KSB7XHJcbiAgICByZXR1cm4gc2luKDEzICogdCAqIFBJIC8gMikgKiBwb3coMiwgMTAgKiAodCAtIDEpKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZWxhc3RpY091dCh0KSB7XHJcbiAgICByZXR1cm4gc2luKC0xMyAqICh0ICsgMSkgKiBQSSAvIDIpICogcG93KDIsIC0xMCAqIHQpICsgMTtcclxufVxyXG5leHBvcnQgdmFyIHNuYXAgPSBjdWJpY0JlemllcigwLCAxLCBIQUxGLCAxKTtcclxuZXhwb3J0IHZhciBlYXNlSW4gPSBjdWJpY0JlemllciguNDIsIDAsIDEsIDEpO1xyXG5leHBvcnQgdmFyIGVhc2VPdXQgPSBjdWJpY0JlemllcigwLCAwLCAuNTgsIDEpO1xyXG5leHBvcnQgdmFyIGluT3V0ID0gY3ViaWNCZXppZXIoLjQyLCAwLCAuNTgsIDEpO1xyXG5leHBvcnQgdmFyIGxpbmVhciA9IGN1YmljQmV6aWVyKC4yNSwgLjI1LCAuNzUsIC43NSk7XHJcbmV4cG9ydCB2YXIgYmFja0luID0gY3ViaWNCZXppZXIoLjYsIC0uMjgsIC43MzUsIC4wNDUpO1xyXG5leHBvcnQgdmFyIGNpcmNJbiA9IGN1YmljQmV6aWVyKC42LCAuMDQsIC45OCwgLjMzNSk7XHJcbmV4cG9ydCB2YXIgY3ViaWNJbiA9IGN1YmljQmV6aWVyKC41NSwgLjA1NSwgLjY3NSwgLjE5KTtcclxuZXhwb3J0IHZhciBleHBvSW4gPSBjdWJpY0JlemllciguOTUsIC4wNSwgLjc5NSwgLjAzNSk7XHJcbmV4cG9ydCB2YXIgcXVhZEluID0gY3ViaWNCZXppZXIoLjU1LCAuMDg1LCAuNjgsIC41Myk7XHJcbmV4cG9ydCB2YXIgcXVhcnRJbiA9IGN1YmljQmV6aWVyKC44OTUsIC4wMywgLjY4NSwgLjIyKTtcclxuZXhwb3J0IHZhciBxdWludEluID0gY3ViaWNCZXppZXIoLjc1NSwgLjA1LCAuODU1LCAuMDYpO1xyXG5leHBvcnQgdmFyIHNpbmVJbiA9IGN1YmljQmV6aWVyKC40NywgMCwgLjc0NSwgLjcxNSk7XHJcbmV4cG9ydCB2YXIgYmFja091dCA9IGN1YmljQmV6aWVyKC4xNzUsIC44ODUsIC4zMiwgMS4yNzUpO1xyXG5leHBvcnQgdmFyIGNpcmNPdXQgPSBjdWJpY0JlemllciguMDc1LCAuODIsIC4xNjUsIDEpO1xyXG5leHBvcnQgdmFyIGN1YmljT3V0ID0gY3ViaWNCZXppZXIoLjIxNSwgLjYxLCAuMzU1LCAxKTtcclxuZXhwb3J0IHZhciBleHBvT3V0ID0gY3ViaWNCZXppZXIoLjE5LCAxLCAuMjIsIDEpO1xyXG5leHBvcnQgdmFyIHF1YWRPdXQgPSBjdWJpY0JlemllciguMjUsIC40NiwgLjQ1LCAuOTQpO1xyXG5leHBvcnQgdmFyIHF1YXJ0T3V0ID0gY3ViaWNCZXppZXIoLjE2NSwgLjg0LCAuNDQsIDEpO1xyXG5leHBvcnQgdmFyIHF1aW50T3V0ID0gY3ViaWNCZXppZXIoLjIzLCAxLCAuMzIsIDEpO1xyXG5leHBvcnQgdmFyIHNpbmVPdXQgPSBjdWJpY0JlemllciguMzksIC41NzUsIC41NjUsIDEpO1xyXG5leHBvcnQgdmFyIGJhY2tJbk91dCA9IGN1YmljQmV6aWVyKC42OCwgLS41NSwgLjI2NSwgMS41NSk7XHJcbmV4cG9ydCB2YXIgY2lyY0luT3V0ID0gY3ViaWNCZXppZXIoLjc4NSwgLjEzNSwgLjE1LCAuODYpO1xyXG5leHBvcnQgdmFyIGN1YmljSW5PdXQgPSBjdWJpY0JlemllciguNjQ1LCAuMDQ1LCAuMzU1LCAxKTtcclxuZXhwb3J0IHZhciBleHBvSW5PdXQgPSBjdWJpY0JlemllcigxLCAwLCAwLCAxKTtcclxuZXhwb3J0IHZhciBxdWFkSW5PdXQgPSBjdWJpY0JlemllciguNDU1LCAuMDMsIC41MTUsIC45NTUpO1xyXG5leHBvcnQgdmFyIHF1YXJ0SW5PdXQgPSBjdWJpY0JlemllciguNzcsIDAsIC4xNzUsIDEpO1xyXG5leHBvcnQgdmFyIHF1aW50SW5PdXQgPSBjdWJpY0JlemllciguODYsIDAsIC4wNywgMSk7XHJcbmV4cG9ydCB2YXIgc2luZUluT3V0ID0gY3ViaWNCZXppZXIoLjQ0NSwgLjA1LCAuNTUsIC45NSk7XHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zaXRpb24oX2EpIHtcclxuICAgIHZhciBfYiA9IF9hLmVhc2UsIGVhc2UgPSBfYiA9PT0gdm9pZCAwID8gZWFzZUluIDogX2IsIGR1cmF0aW9uID0gX2EuZHVyYXRpb24sIF9jID0gX2EubG9vcCwgbG9vcCA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLCBfZCA9IF9hLmRlbGF5LCBkZWxheSA9IF9kID09PSB2b2lkIDAgPyAwIDogX2Q7XHJcbiAgICB2YXIgZGlmZiA9IDA7XHJcbiAgICB2YXIgc3RhcnQsIGNoYW5nZSwgZW5kZWQ7XHJcbiAgICBmdW5jdGlvbiBpbml0KCkge1xyXG4gICAgICAgIHN0YXJ0ID0gbm93KCk7XHJcbiAgICAgICAgIXRoaXMucnVubmluZyAmJiAodGhpcy5ydW5uaW5nID0gdHJ1ZSk7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUuYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhbmltYXRlKHRpbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5wYXVzZWQgfHwgIWNoYW5nZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBmcmFjdGlvbiA9ICh0aW1lIC0gc3RhcnQgKyBkaWZmKSAvIChkdXJhdGlvbiB8fCA4MDApO1xyXG4gICAgICAgIHZhciBwcm9ncmVzcyA9IGVhc2UoZnJhY3Rpb24gPiAxID8gZnJhY3Rpb24gPSAxIDogZnJhY3Rpb24pO1xyXG4gICAgICAgIGNoYW5nZShwcm9ncmVzcyk7XHJcbiAgICAgICAgaWYgKGZyYWN0aW9uIDwgMSkge1xyXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobG9vcCkge1xyXG4gICAgICAgICAgICBkaWZmID0gMDtcclxuICAgICAgICAgICAgaW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGVuZGVkICYmIGVuZGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwYXVzZWQ6IGZhbHNlLFxyXG4gICAgICAgIHJ1bm5pbmc6IGZhbHNlLFxyXG4gICAgICAgIG9uOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgZXZlbnQgPT09ICdlbmRlZCcgJiYgKGVuZGVkID0gaGFuZGxlcik7XHJcbiAgICAgICAgICAgIGV2ZW50ID09PSAnY2hhbmdlJyAmJiAoY2hhbmdlID0gaGFuZGxlcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBydW46IGZ1bmN0aW9uIChkLCBsKSB7XHJcbiAgICAgICAgICAgIGRlbGF5ID0gbCB8fCBkZWxheSB8fCAwO1xyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IGQgfHwgZHVyYXRpb24gfHwgODAwO1xyXG4gICAgICAgICAgICBkZWxheSA+IDAgPyBzZXRUaW1lb3V0KGluaXQuYmluZCh0aGlzKSwgZGVsYXkpIDogaW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnJ1bm5pbmcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgZGlmZiArPSBub3coKSAtIHN0YXJ0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGxheTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucnVubmluZylcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgaW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxyXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5pbXBvcnQgaGFzaCBmcm9tICdoYXNoLXN1bSc7XHJcbmltcG9ydCB0cmFuc2l0aW9uLCB7IGVhc2VJbiB9IGZyb20gJy4vdHJhbnNpdGlvbic7XHJcbmV4cG9ydCBmdW5jdGlvbiBhbmltYXRlKG9wdGlvbnMsIHJ1bikge1xyXG4gICAgdmFyIHN0eWxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2FuaW1hdGlvbi1zdHlsZS1zaGVldF0nKTtcclxuICAgIGlmICghc3R5bGUpIHtcclxuICAgICAgICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XHJcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCdhbmltYXRpb24tc3R5bGUtc2hlZXQnLCAnJyk7XHJcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XHJcbiAgICB9XHJcbiAgICB2YXIgZWwsIHN0eWxlSW5kZXg7XHJcbiAgICB2YXIgc3R5bGVTaGVldCA9IHN0eWxlLnNoZWV0O1xyXG4gICAgdmFyIGNsYXNzTmFtZSA9IFwiYW5pbWF0aW9uX1wiICsgaGFzaChydW4pO1xyXG4gICAgdmFyIF9hID0gX19hc3NpZ24oeyBkZWxheTogMCwgZHVyYXRpb246IDQwMCwgZWFzZTogZWFzZUluIH0sIG9wdGlvbnMpLCBlYXNlID0gX2EuZWFzZSwgZGVsYXkgPSBfYS5kZWxheSwgZHVyYXRpb24gPSBfYS5kdXJhdGlvbjtcclxuICAgIHZhciBpbkFuaW1hdGlvbiA9IHRyYW5zaXRpb24oeyBkdXJhdGlvbjogZHVyYXRpb24sIGRlbGF5OiBkZWxheSwgZWFzZTogZWFzZSB9KTtcclxuICAgIHZhciBvdXRBbmltYXRpb24gPSB0cmFuc2l0aW9uKHsgZHVyYXRpb246IGR1cmF0aW9uLCBkZWxheTogZGVsYXksIGVhc2U6IGZ1bmN0aW9uICh4KSB7IHJldHVybiAxIC0gZWFzZSgxIC0geCk7IH0gfSk7XHJcbiAgICBmdW5jdGlvbiBzZXRDaGFuZ2VDQihub2RlLCBhbmltYXRpb24pIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsID0gbm9kZTtcclxuICAgICAgICB2YXIgYW5pbWUgPSBhbmltYXRpb24gPT09ICdpbicgPyBpbkFuaW1hdGlvbiA6IG91dEFuaW1hdGlvbjtcclxuICAgICAgICB2YXIgY2hhbmdlID0gcnVuKG5vZGUpO1xyXG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcclxuICAgICAgICBhbmltZS5vbignY2hhbmdlJywgZnVuY3Rpb24gKHByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgIHN0eWxlU2hlZXQuY3NzUnVsZXMubGVuZ3RoICYmIHN0eWxlU2hlZXQuZGVsZXRlUnVsZShzdHlsZUluZGV4KTtcclxuICAgICAgICAgICAgdmFyIHN0eWxlVHh0ID0gY2hhbmdlKGFuaW1hdGlvbiA9PT0gJ2luJyA/IHByb2dyZXNzIDogMSAtIHByb2dyZXNzKTtcclxuICAgICAgICAgICAgc3R5bGVTaGVldC5pbnNlcnRSdWxlKFwiLlwiICsgY2xhc3NOYW1lICsgXCJ7XCIgKyBzdHlsZVR4dCArIFwifVwiKTtcclxuICAgICAgICAgICAgc3R5bGVJbmRleCA9IHN0eWxlU2hlZXQuY3NzUnVsZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBhbmltZS5ydW4uYXBwbHkoYW5pbWUsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdGF0ZTogJ2luJyxcclxuICAgICAgICBzdGFydGVkOiBmYWxzZSxcclxuICAgICAgICBlbmRlZDogZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlciAmJiBoYW5kbGVyKCk7XHJcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0LmRlbGV0ZVJ1bGUoc3R5bGVJbmRleCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGluQW5pbWF0aW9uLm9uKCdlbmRlZCcsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgb3V0QW5pbWF0aW9uLm9uKCdlbmRlZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcnVuOiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChzZWxmLnN0YXRlID09PSAnaW4nKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmluLmFwcGx5KHNlbGYsIFtub2RlXS5jb25jYXQoYXJncykpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdvdXQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5vdXQuYXBwbHkoc2VsZiwgW25vZGVdLmNvbmNhdChhcmdzKSk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gJ2luJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW46IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldENoYW5nZUNCLmFwcGx5KHZvaWQgMCwgW25vZGUsICdpbiddLmNvbmNhdChhcmdzKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvdXQ6IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldENoYW5nZUNCLmFwcGx5KHZvaWQgMCwgW25vZGUsICdvdXQnXS5jb25jYXQoYXJncykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxyXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5pbXBvcnQgeyBhbmltYXRlIH0gZnJvbSAnLi90b29scyc7XHJcbmltcG9ydCB7IGN1YmljT3V0IH0gZnJvbSAnLi90cmFuc2l0aW9uJztcclxuZXhwb3J0IGZ1bmN0aW9uIEZhZGVBbmltYXRpb24ob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkZWxheTogMCwgZHVyYXRpb246IDQwMCB9O1xyXG4gICAgcmV0dXJuIGFuaW1hdGUob3B0aW9ucywgZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICB2YXIgb3BhY2l0eSA9ICsoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5vcGFjaXR5IHx8IDApO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocHJvZ3Jlc3MpIHsgcmV0dXJuIFwib3BhY2l0eTogXCIgKyBwcm9ncmVzcyAqIG9wYWNpdHkgKyBcIjtcIjsgfTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBGbHlBbmltYXRpb24ob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkZWxheTogMCwgZHVyYXRpb246IDQwMCwgeDogMCwgeTogMCwgZWFzZTogY3ViaWNPdXQgfTtcclxuICAgIHJldHVybiBhbmltYXRlKG9wdGlvbnMsIGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdmFyIG9wYWNpdHksIHRyYW5zZm9ybTtcclxuICAgICAgICB2YXIgX2EgPSBfX2Fzc2lnbih7IHg6IDAsIHk6IDAgfSwgb3B0aW9ucyksIHggPSBfYS54LCB5ID0gX2EueTtcclxuICAgICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xyXG4gICAgICAgIG9wYWNpdHkgPSArKHN0eWxlLm9wYWNpdHkgfHwgMCk7XHJcbiAgICAgICAgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IChzdHlsZS50cmFuc2Zvcm0gPyBzdHlsZS50cmFuc2Zvcm0gKyBcIiBcIiA6ICcnKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHByb2dyZXNzKSB7IHJldHVybiBcIm9wYWNpdHk6IFwiICsgcHJvZ3Jlc3MgKiBvcGFjaXR5ICsgXCI7IFwiICtcclxuICAgICAgICAgICAgKFwidHJhbnNmb3JtOiBcIiArIHRyYW5zZm9ybSArIFwidHJhbnNsYXRlKFwiICsgKDEgLSBwcm9ncmVzcykgKiAoeCB8fCAwKSArIFwicHgsIFwiICsgKDEgLSBwcm9ncmVzcykgKiAoeSB8fCAwKSArIFwicHgpO1wiKTsgfTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBTbGlkZUFuaW1hdGlvbihvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRlbGF5OiAwLCBkdXJhdGlvbjogNDAwLCBlYXNlOiBjdWJpY091dCB9O1xyXG4gICAgcmV0dXJuIGFuaW1hdGUob3B0aW9ucywgZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICB2YXIgb3BhY2l0eSwgaGVpZ2h0LCBwYWRkaW5nVG9wLCBwYWRkaW5nQm90dG9tLCBtYXJnaW5Ub3AsIG1hcmdpbkJvdHRvbSwgYm9yZGVyVG9wV2lkdGgsIGJvcmRlckJvdHRvbVdpZHRoO1xyXG4gICAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XHJcbiAgICAgICAgb3BhY2l0eSA9ICsoc3R5bGUub3BhY2l0eSB8fCAwKTtcclxuICAgICAgICBoZWlnaHQgPSBwYXJzZUZsb2F0KHN0eWxlLmhlaWdodCB8fCAnMCcpO1xyXG4gICAgICAgIG1hcmdpblRvcCA9IHBhcnNlRmxvYXQoc3R5bGUubWFyZ2luVG9wIHx8ICcwJyk7XHJcbiAgICAgICAgcGFkZGluZ1RvcCA9IHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ1RvcCB8fCAnMCcpO1xyXG4gICAgICAgIG1hcmdpbkJvdHRvbSA9IHBhcnNlRmxvYXQoc3R5bGUubWFyZ2luQm90dG9tIHx8ICcwJyk7XHJcbiAgICAgICAgcGFkZGluZ0JvdHRvbSA9IHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ0JvdHRvbSB8fCAnMCcpO1xyXG4gICAgICAgIGJvcmRlclRvcFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJUb3BXaWR0aCB8fCAnMCcpO1xyXG4gICAgICAgIGJvcmRlckJvdHRvbVdpZHRoID0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJCb3R0b21XaWR0aCB8fCAnMCcpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocHJvZ3Jlc3MpIHsgcmV0dXJuIFwib3ZlcmZsb3c6IGhpZGRlbjtcIiArXHJcbiAgICAgICAgICAgIChcImhlaWdodDogXCIgKyBwcm9ncmVzcyAqIGhlaWdodCArIFwicHg7XCIpICtcclxuICAgICAgICAgICAgKFwibWFyZ2luLXRvcDogXCIgKyBwcm9ncmVzcyAqIG1hcmdpblRvcCArIFwicHg7XCIpICtcclxuICAgICAgICAgICAgKFwicGFkZGluZy10b3A6IFwiICsgcHJvZ3Jlc3MgKiBwYWRkaW5nVG9wICsgXCJweDtcIikgK1xyXG4gICAgICAgICAgICAoXCJtYXJnaW4tYm90dG9tOiBcIiArIHByb2dyZXNzICogbWFyZ2luQm90dG9tICsgXCJweDtcIikgK1xyXG4gICAgICAgICAgICAoXCJwYWRkaW5nLWJvdHRvbTogXCIgKyBwcm9ncmVzcyAqIHBhZGRpbmdCb3R0b20gKyBcInB4O1wiKSArXHJcbiAgICAgICAgICAgIChcImJvcmRlci10b3Atd2lkdGg6IFwiICsgcHJvZ3Jlc3MgKiBib3JkZXJUb3BXaWR0aCArIFwicHg7XCIpICtcclxuICAgICAgICAgICAgKFwib3BhY2l0eTogXCIgKyBNYXRoLm1pbihwcm9ncmVzcyAqIDIwLCAxKSAqIG9wYWNpdHkgKyBcIjtcIikgK1xyXG4gICAgICAgICAgICAoXCJib3JkZXItYm90dG9tLXdpZHRoOiBcIiArIHByb2dyZXNzICogYm9yZGVyQm90dG9tV2lkdGggKyBcInB4O1wiKTsgfTtcclxuICAgIH0pO1xyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgXyRDb21wQ3RyLFxyXG4gIF8kLFxyXG4gIF8kZCxcclxuICBfJGEsXHJcbiAgXyRjZSxcclxuICBfJGN0LFxyXG4gIF8kdHUsXHJcbiAgXyRycixcclxuICBfJHNhLFxyXG4gIF8kYWwsXHJcbiAgXyRybCxcclxuICBfJGlzLFxyXG4gIF8kZHMsXHJcbiAgXyRzZXRSZWYsXHJcbiAgXyRub29wLFxyXG4gIF8kY3UsXHJcbiAgXyRlbXB0eUVsc2UsXHJcbiAgXyRleHRlbmRzLFxyXG59IGZyb20gJ3RyZWJvci90b29scyc7XHJcbmltcG9ydCB7IFNsaWRlQW5pbWF0aW9uIH0gZnJvbSAndHJlYm9yLXRyYW5zaXRpb25zJztcclxuZnVuY3Rpb24gaWZDb25kaXRpb25fMShfJHN0YXRlKSB7XHJcbiAgdmFyIF8kZnJhZywgZGl2XzEsIHR4dF8xLCBfcmVmcztcclxuICBfJGZyYWcgPSBfJGQoKTtcclxuICBfcmVmcyA9IF8kc3RhdGUuJHJlZnM7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6ICdpZicsXHJcblxyXG4gICAgJGNyZWF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGRpdl8xID0gXyRjZSgpO1xyXG4gICAgICB0eHRfMSA9IF8kY3QoJ0hlbGxvIHdvcmQhJyk7XHJcbiAgICAgIF8kc2V0UmVmKF9yZWZzLCAnYm94JywgZGl2XzEpO1xyXG4gICAgfSxcclxuXHJcbiAgICAkbW91bnQ6IGZ1bmN0aW9uKHBhcmVudCwgc2libGluZykge1xyXG4gICAgICB0aGlzLiR1bm1vdW50KCk7XHJcbiAgICAgIF8kYShfJChwYXJlbnQpLCBfJGZyYWcsIF8kKHNpYmxpbmcpKTtcclxuICAgIH0sXHJcblxyXG4gICAgJHVwZGF0ZTogXyRub29wLFxyXG5cclxuICAgICR1bm1vdW50OiBmdW5jdGlvbigpIHtcclxuICAgICAgXyRhKGRpdl8xLCB0eHRfMSk7XHJcbiAgICAgIF8kYShfJGZyYWcsIGRpdl8xKTtcclxuICAgIH0sXHJcblxyXG4gICAgJGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLiR1bm1vdW50KCk7XHJcbiAgICAgIF8kcnIoX3JlZnMsICdib3gnLCBkaXZfMSk7XHJcbiAgICAgIF8kZnJhZyA9IGRpdl8xID0gdHh0XzEgPSBfcmVmcyA9IHZvaWQgMDtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNvbmRpdGlvbl8xKF8kc3RhdGUpIHtcclxuICBpZiAoXyRzdGF0ZS52aXNpYmxlKVxyXG4gICAgcmV0dXJuIGlmQ29uZGl0aW9uXzEoXyRzdGF0ZSk7XHJcbiAgZWxzZVxyXG4gICAgcmV0dXJuIF8kZW1wdHlFbHNlKCk7XHJcbn1cclxuZnVuY3Rpb24gXyR0cGxBbmltYXRpb24oXyRzdGF0ZSkge1xyXG4gIHZhciBfJGZyYWcsIGlucHV0XzEsIGNoYW5nZUV2ZW50XzEsIGhhbmRsZXJDaGFuZ2VFdmVudF8xLCBsYWJlbF8xLCB0eHRfMSwgc2V0VHh0XzEsIGNvbmRpdGlvbkFuY2hvcl8xLCBjb25kaXRpb25CbG9ja18xO1xyXG4gIF8kZnJhZyA9IF8kZCgpO1xyXG4gIGNoYW5nZUV2ZW50XzEgPSBmdW5jdGlvbihfJHN0YXRlLCAkZXZlbnQsICRlbCkge1xyXG4gICAgXyRzdGF0ZS5vbkNoYW5nZSgkZWwuY2hlY2tlZCk7XHJcbiAgfTtcclxuICBzZXRUeHRfMSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuICdWaXNpYmxlOiAnO1xyXG4gIH07XHJcbiAgJysoXyRzdGF0ZS52aXNpYmxlKSsnO1xyXG4gICcnO1xyXG4gIGNvbmRpdGlvbkFuY2hvcl8xID0gXyRjdCgpO1xyXG4gIHJldHVybiB7XHJcbiAgICAkY3JlYXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgaW5wdXRfMSA9IF8kY2UoJ2lucHV0Jyk7XHJcbiAgICAgIGxhYmVsXzEgPSBfJGNlKCdsYWJlbCcpO1xyXG4gICAgICB0eHRfMSA9IF8kY3QoKTtcclxuICAgICAgdHh0XzEuZGF0YSA9IHNldFR4dF8xKF8kc3RhdGUpO1xyXG4gICAgICBjb25kaXRpb25CbG9ja18xID0gY29uZGl0aW9uXzEoXyRzdGF0ZSk7XHJcbiAgICAgIGNvbmRpdGlvbkJsb2NrXzEuJGNyZWF0ZSgpO1xyXG4gICAgICBfJHNhKGlucHV0XzEsIFsnaWQnLCAndmlzaWJsZSddKTtcclxuICAgICAgXyRzYShpbnB1dF8xLCBbJ3R5cGUnLCAnY2hlY2tib3gnXSk7XHJcbiAgICAgIF8kYWwoaW5wdXRfMSwgJ2NoYW5nZScsIGhhbmRsZXJDaGFuZ2VFdmVudF8xID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICBjaGFuZ2VFdmVudF8xKF8kc3RhdGUsIGV2ZW50LCBpbnB1dF8xKTtcclxuICAgICAgfSk7XHJcbiAgICAgIF8kc2EobGFiZWxfMSwgWydmb3InLCAndmlzaWJsZSddKTtcclxuICAgIH0sXHJcblxyXG4gICAgJG1vdW50OiBmdW5jdGlvbihwYXJlbnQsIHNpYmxpbmcpIHtcclxuICAgICAgdGhpcy4kdW5tb3VudCgpO1xyXG4gICAgICBfJGlzKFxyXG4gICAgICAgICdzY29wZV8yZDgyNjc0MCcsXHJcbiAgICAgICAgJ2RpdiB7d2lkdGg6MTI1cHg7cGFkZGluZzo0NXB4IDA7Y29sb3I6d2hpdGU7dGV4dC1hbGlnbjpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjpibGFjazt9J1xyXG4gICAgICApO1xyXG4gICAgICBfJGEoXyQocGFyZW50KSwgXyRmcmFnLCBfJChzaWJsaW5nKSk7XHJcbiAgICAgIHRoaXMuJHNpYmxpbmdFbCA9IF8kKHNpYmxpbmcpO1xyXG4gICAgICB0aGlzLiRwYXJlbnRFbCA9IHNpYmxpbmcgJiYgXyQoc2libGluZykucGFyZW50RWxlbWVudCB8fCBfJChwYXJlbnQpO1xyXG4gICAgfSxcclxuXHJcbiAgICAkdXBkYXRlOiBmdW5jdGlvbihfJHN0YXRlKSB7XHJcbiAgICAgIF8kdHUodHh0XzEsIHNldFR4dF8xKF8kc3RhdGUpKTtcclxuICAgICAgY29uZGl0aW9uQmxvY2tfMSA9IF8kY3UoY29uZGl0aW9uQmxvY2tfMSwgY29uZGl0aW9uXzEsIHVuZGVmaW5lZCwgY29uZGl0aW9uQW5jaG9yXzEsIF8kc3RhdGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAkdW5tb3VudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIF8kYShfJGZyYWcsIGlucHV0XzEpO1xyXG4gICAgICBfJGEobGFiZWxfMSwgdHh0XzEpO1xyXG4gICAgICBfJGEoXyRmcmFnLCBsYWJlbF8xKTtcclxuICAgICAgXyRhKF8kZnJhZywgY29uZGl0aW9uQW5jaG9yXzEpO1xyXG4gICAgICBjb25kaXRpb25CbG9ja18xLiRtb3VudChfJGZyYWcsIGNvbmRpdGlvbkFuY2hvcl8xKTtcclxuICAgIH0sXHJcblxyXG4gICAgJGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLiR1bm1vdW50KCk7XHJcbiAgICAgIHRoaXMuJHBhcmVudCA9IG51bGw7XHJcbiAgICAgIHRoaXMuJHBhcmVudEVsID0gbnVsbDtcclxuICAgICAgdGhpcy4kc2libGluZ0VsID0gbnVsbDtcclxuICAgICAgdGhpcy4kY2hpbGRyZW4uc3BsaWNlKDAsIHRoaXMuJGNoaWxkcmVuLmxlbmd0aCk7XHJcbiAgICAgIF8kZHMoJ3Njb3BlXzJkODI2NzQwJyk7XHJcbiAgICAgIF8kcmwoaW5wdXRfMSwgJ2NoYW5nZScsIGhhbmRsZXJDaGFuZ2VFdmVudF8xKTtcclxuICAgICAgY29uZGl0aW9uQmxvY2tfMS4kZGVzdHJveSgpO1xyXG4gICAgICBkZWxldGUgXyRzdGF0ZS4kcm9vdDtcclxuICAgICAgXyRmcmFnID0gaW5wdXRfMSA9IGNoYW5nZUV2ZW50XzEgPSBoYW5kbGVyQ2hhbmdlRXZlbnRfMSA9IGxhYmVsXzEgPSB0eHRfMSA9IHNldFR4dF8xID0gY29uZGl0aW9uQW5jaG9yXzEgPSBjb25kaXRpb25CbG9ja18xID0gdm9pZCAwO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxudmFyIGFuaW1hdGlvbiA9IFNsaWRlQW5pbWF0aW9uKHtcclxuICB5OiAzMDAsXHJcbiAgZHVyYXRpb246IDEyMDBcclxufSk7XHJcbmZ1bmN0aW9uIEFuaW1hdGlvbihfJGF0dHJzLCBfJHBhcmVudCkge1xyXG4gIF8kQ29tcEN0ci5jYWxsKHRoaXMsIF8kYXR0cnMsIF8kdHBsQW5pbWF0aW9uLCB7XHJcbiAgICBtb2RlbDoge1xyXG4gICAgICB2aXNpYmxlOiBmYWxzZSxcclxuXHJcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHJlZnMgPSB0aGlzLiRyZWZzO1xyXG4gICAgICAgIGFuaW1hdGlvbi5lbmRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICF2YWx1ZSAmJiBfdGhpcy4kdXBkYXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICB0aGlzLiRzZXQoJ3Zpc2libGUnLCB2YWx1ZSk7XHJcbiAgICAgICAgICBhbmltYXRpb24uaW4ocmVmcy5ib3gpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLnZpc2libGUgPSB2YWx1ZTtcclxuICAgICAgICAgIGFuaW1hdGlvbi5vdXQocmVmcy5ib3gpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIF8kcGFyZW50KTtcclxuICAhXyRwYXJlbnQgJiYgdGhpcy4kY3JlYXRlKCk7XHJcbn1cclxuXyRleHRlbmRzKEFuaW1hdGlvbiwgXyRDb21wQ3RyKTtcclxuZXhwb3J0IGRlZmF1bHQgQW5pbWF0aW9uO1xyXG4iLCJpbXBvcnQgQW5pbWF0aW9uIGZyb20gJy4vY29tcG9uZW50cy9hbmltYXRpb24uaHRtbCc7XHJcblxyXG5jb25zdCBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKCk7XHJcblxyXG5hbmltYXRpb24uJG1vdW50KCdtYWluJyk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./main.ts\n");

/***/ })

/******/ });